[
  {
    "objectID": "oldsexdata.html",
    "href": "oldsexdata.html",
    "title": "Untitled",
    "section": "",
    "text": "CAPES_AREA_MAP = {\n    1: \"MATEMÁTICA / PROBABILIDADE E ESTATÍSTICA\",\n    2: \"CIÊNCIA DA COMPUTAÇÃO\",\n    3: \"ASTRONOMIA / FÍSICA\",\n    4: \"QUÍMICA\",\n    5: \"GEOCIÊNCIAS\",\n    6: \"CIÊNCIAS BIOLÓGICAS I\",\n    7: \"BIODIVERSIDADE\",\n    8: \"CIÊNCIAS BIOLÓGICAS II\",\n    9: \"CIÊNCIAS BIOLÓGICAS III\",\n    10: \"ENGENHARIAS I\",\n    11: \"ARTES\",\n    12: \"ENGENHARIAS II\",\n    13: \"ENGENHARIAS III\",\n    14: \"ENGENHARIAS IV\",\n    15: \"MEDICINA I\",\n    16: \"MEDICINA II\",\n    17: \"MEDICINA III\",\n    18: \"ODONTOLOGIA\",\n    19: \"FARMÁCIA\",\n    20: \"ENFERMAGEM\",\n    21: \"EDUCAÇÃO FÍSICA\",\n    22: \"SAÚDE COLETIVA\",\n    23: \"ZOOTECNIA / RECURSOS PESQUEIROS\",\n    24: \"MEDICINA VETERINÁRIA\",\n    25: \"CIÊNCIA DE ALIMENTOS\",\n    26: \"DIREITO\",\n    27: \"ADMINISTRAÇÃO PÚBLICA E DE EMPRESAS, CIÊNCIAS CONTÁBEIS E TURISMO\",\n    28: \"ECONOMIA\",\n    29: \"ARQUITETURA, URBANISMO E DESIGN\",\n    30: \"PLANEJAMENTO URBANO E REGIONAL / DEMOGRAFIA\",\n    31: \"COMUNICAÇÃO E INFORMAÇÃO\",\n    32: \"SERVIÇO SOCIAL\",\n    33: \"FILOSOFIA\",\n    34: \"SOCIOLOGIA\",\n    35: \"ANTROPOLOGIA / ARQUEOLOGIA\",\n    36: \"GEOGRAFIA\",\n    37: \"PSICOLOGIA\",\n    38: \"EDUCAÇÃO\",\n    39: \"CIÊNCIA POLÍTICA E RELAÇÕES INTERNACIONAIS\",\n    40: \"HISTÓRIA\",\n    41: \"LINGUÍSTICA E LITERATURA\",\n    42: \"CIÊNCIAS AGRÁRIAS I\",\n    44: \"CIÊNCIAS DA RELIGIÃO E TEOLOGIA\",\n    45: \"INTERDISCIPLINAR\",\n    46: \"ENSINO\",\n    47: \"MATERIAIS\",\n    48: \"BIOTECNOLOGIA\",\n    49: \"CIÊNCIAS AMBIENTAIS\",\n    50: \"NUTRIÇÃO\"\n}\n\n\nimport json\nimport pandas as pd\nimport plotly.express as px\n\n# Define the file path\nfile_path = \"Resources/Data/Unsupported/sexo.json\"\n\n# Read the JSON file line by line\njson_data = []\nwith open(file_path, \"r\", encoding=\"utf-8\") as file:\n    for line in file:\n        try:\n            json_data.append(json.loads(line))  # Load each line separately\n        except json.JSONDecodeError as e:\n            print(f\"Error decoding JSON on line: {line}\\nError: {e}\")\n\n# Convert JSON data to DataFrame\ndata = []\nfor record in json_data:\n    if record.get(\"estado\") == \"SP\":  # Filter for São Paulo (SP)\n        contadores = record[\"contadores\"][\"acumulador\"]\n        data.append({\n            \"FEMININO\": int(contadores[\"FEMININO\"][\"$numberInt\"]),\n            \"MASCULINO\": int(contadores[\"MASCULINO\"][\"$numberInt\"]),\n            \"NÃO INFORMADO\": int(contadores[\"NÃO INFORMADO\"][\"$numberInt\"])\n        })\n\n# Convert to Pandas DataFrame\ndf = pd.DataFrame(data)\n\n# Aggregate totals\nsex_totals = df.sum()\n\n# Create pie chart\nfig = px.pie(\n    names=sex_totals.index,\n    values=sex_totals.values,\n    title=\"Distribuição de Estudantes por Sexo em São Paulo (SP)\",\n    labels={\"names\": \"Sexo\", \"values\": \"Quantidade\"}\n)\n\n# Show the plot\nfig.show()\n\n                                                \n\n\n\nimport json\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Define the file path\nfile_path = \"Resources/Data/Unsupported/sexo.json\"\n\n# Load the JSON file line by line (handling line-delimited JSON)\njson_data = []\nwith open(file_path, \"r\", encoding=\"utf-8\") as file:\n    for line in file:\n        try:\n            json_data.append(json.loads(line))\n        except json.JSONDecodeError as e:\n            print(f\"Error decoding JSON on line: {line}\\nError: {e}\")\n\n# CAPES Area Map\nCAPES_AREA_MAP = {\n    1: \"MATEMÁTICA / PROBABILIDADE E ESTATÍSTICA\", 2: \"CIÊNCIA DA COMPUTAÇÃO\", 3: \"ASTRONOMIA / FÍSICA\",\n    4: \"QUÍMICA\", 5: \"GEOCIÊNCIAS\", 6: \"CIÊNCIAS BIOLÓGICAS I\", 7: \"BIODIVERSIDADE\",\n    8: \"CIÊNCIAS BIOLÓGICAS II\", 9: \"CIÊNCIAS BIOLÓGICAS III\", 10: \"ENGENHARIAS I\",\n    11: \"ARTES\", 12: \"ENGENHARIAS II\", 13: \"ENGENHARIAS III\", 14: \"ENGENHARIAS IV\",\n    15: \"MEDICINA I\", 16: \"MEDICINA II\", 17: \"MEDICINA III\", 18: \"ODONTOLOGIA\",\n    19: \"FARMÁCIA\", 20: \"ENFERMAGEM\", 21: \"EDUCAÇÃO FÍSICA\", 22: \"SAÚDE COLETIVA\",\n    23: \"ZOOTECNIA / RECURSOS PESQUEIROS\", 24: \"MEDICINA VETERINÁRIA\", 25: \"CIÊNCIA DE ALIMENTOS\",\n    26: \"DIREITO\", 27: \"ADMINISTRAÇÃO, CIÊNCIAS CONTÁBEIS E TURISMO\", 28: \"ECONOMIA\",\n    29: \"ARQUITETURA, URBANISMO E DESIGN\", 30: \"PLANEJAMENTO URBANO / DEMOGRAFIA\",\n    31: \"COMUNICAÇÃO E INFORMAÇÃO\", 32: \"SERVIÇO SOCIAL\", 33: \"FILOSOFIA\", 34: \"SOCIOLOGIA\",\n    35: \"ANTROPOLOGIA / ARQUEOLOGIA\", 36: \"GEOGRAFIA\", 37: \"PSICOLOGIA\", 38: \"EDUCAÇÃO\",\n    39: \"CIÊNCIA POLÍTICA E RELAÇÕES INTERNACIONAIS\", 40: \"HISTÓRIA\", 41: \"LINGUÍSTICA E LITERATURA\",\n    42: \"CIÊNCIAS AGRÁRIAS I\", 44: \"CIÊNCIAS DA RELIGIÃO E TEOLOGIA\", 45: \"INTERDISCIPLINAR\",\n    46: \"ENSINO\", 47: \"MATERIAIS\", 48: \"BIOTECNOLOGIA\", 49: \"CIÊNCIAS AMBIENTAIS\", 50: \"NUTRIÇÃO\"\n}\n\n# Function to format area titles with line breaks and area number\ndef format_area_title(area_code, area_name, max_words=3):\n    words = area_name.split()\n    if len(words) &gt; max_words:\n        # Insert line break after 'max_words' words\n        formatted_title = \"&lt;br&gt;\".join([\" \".join(words[i:i + max_words]) for i in range(0, len(words), max_words)])\n    else:\n        formatted_title = area_name\n    return f\"{formatted_title}&lt;br&gt;({area_code})\"\n\n# Process the data\narea_sex_data = {area: {\"FEMININO\": 0, \"MASCULINO\": 0, \"NÃO INFORMADO\": 0} for area in CAPES_AREA_MAP.keys()}\n\nfor record in json_data:\n    area_code = int(record[\"area\"]) if record[\"area\"].isdigit() else None\n    if area_code and area_code in area_sex_data:\n        contadores = record[\"contadores\"][\"acumulador\"]\n        area_sex_data[area_code][\"FEMININO\"] += int(contadores[\"FEMININO\"][\"$numberInt\"])\n        area_sex_data[area_code][\"MASCULINO\"] += int(contadores[\"MASCULINO\"][\"$numberInt\"])\n        area_sex_data[area_code][\"NÃO INFORMADO\"] += int(contadores[\"NÃO INFORMADO\"][\"$numberInt\"])\n\n# Create a 5x10 grid of pie charts with improved titles\nformatted_titles = [format_area_title(code, name) for code, name in CAPES_AREA_MAP.items()]\n\nfig = make_subplots(rows=10, cols=5, subplot_titles=formatted_titles, specs=[[{\"type\": \"domain\"}]*5]*10)\n\nrow, col = 1, 1\nfor area_code, sex_counts in area_sex_data.items():\n    values = list(sex_counts.values())\n    labels = list(sex_counts.keys())\n\n    if sum(values) &gt; 0:  # Avoid empty charts\n        fig.add_trace(\n            go.Pie(labels=labels, values=values, showlegend=False, textinfo=\"percent\"),\n            row=row, col=col\n        )\n\n    # Update row and column for next plot\n    col += 1\n    if col &gt; 5:  # Move to the next row after 5 columns\n        col = 1\n        row += 1\n\n\n\n# Update layout with increased top margin\nfig.update_layout(\n    title_text=\"Distribuição de Estudantes por Sexo em Cada Área\",\n    title_x=0.5,  # Center the title\n    title_y=0.99,  # Adjust the title position slightly lower\n    margin=dict(t=120, b=50, l=50, r=50),  # Increase top margin (t=250)\n    height=2000, width=1200\n)\n\n# Show the plot\nfig.show()\n\n                                                \n\n\n\nimport json\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Define file path for JSON data\nfile_path = \"Resources/Data/Unsupported/sexo.json\"\n\n# Load JSON data (handling line-delimited format)\njson_data = []\nwith open(file_path, \"r\", encoding=\"utf-8\") as file:\n    for line in file:\n        try:\n            json_data.append(json.loads(line))\n        except json.JSONDecodeError as e:\n            print(f\"Error decoding JSON on line: {line}\\nError: {e}\")\n\n# Define the region-to-state mapping\nregion_map = {\n    \"CENTRO-OESTE\": [\"DF\", \"GO\", \"MT\", \"MS\"],\n    \"NORDESTE\": [\"PB\", \"PE\", \"RN\", \"MA\", \"BA\", \"CE\", \"SE\", \"AL\", \"PI\"],\n    \"NORTE\": [\"PA\", \"AM\", \"AC\", \"RO\", \"TO\", \"AP\", \"RR\"],\n    \"SUDESTE\": [\"SP\", \"RJ\", \"MG\", \"ES\"],\n    \"SUL\": [\"PR\", \"SC\", \"RS\"]\n}\n\n# Reverse the mapping to get state-to-region\nstate_to_region = {state: region for region, states in region_map.items() for state in states}\n\n# Filter records for Interdisciplinary area (45)\ninterdisciplinary_data = [record for record in json_data if record[\"area\"] == \"45\"]\n\n# Process the data - Group by state\nstate_sex_data = {state: {\"FEMININO\": 0, \"MASCULINO\": 0, \"NÃO INFORMADO\": 0} for state in state_to_region.keys()}\n\nfor record in interdisciplinary_data:\n    state = record[\"estado\"]\n    if state in state_sex_data:  # Only consider valid states\n        contadores = record[\"contadores\"][\"acumulador\"]\n        state_sex_data[state][\"FEMININO\"] += int(contadores[\"FEMININO\"][\"$numberInt\"])\n        state_sex_data[state][\"MASCULINO\"] += int(contadores[\"MASCULINO\"][\"$numberInt\"])\n        state_sex_data[state][\"NÃO INFORMADO\"] += int(contadores[\"NÃO INFORMADO\"][\"$numberInt\"])\n\n# Remove states with zero total students\nstate_sex_data = {state: counts for state, counts in state_sex_data.items() if sum(counts.values()) &gt; 0}\n\n# If no states have data, print a warning and exit\nif not state_sex_data:\n    print(\"⚠ No data available for Interdisciplinary area (45) per state.\")\nelse:\n    # Get sorted list of states with their regions\n    sorted_states = sorted(state_sex_data.keys(), key=lambda x: (state_to_region.get(x, \"ZZZ\"), x))\n\n    # Determine the number of rows needed for a grid layout (5 columns)\n    num_states = len(sorted_states)\n    num_cols = 5\n    num_rows = max((num_states // num_cols) + (1 if num_states % num_cols else 0), 1)  # Ensure at least 1 row\n\n    # Define colors for regions\n    region_colors = {\n        \"CENTRO-OESTE\": \"blue\",\n        \"NORDESTE\": \"green\",\n        \"NORTE\": \"orange\",\n        \"SUDESTE\": \"red\",\n        \"SUL\": \"purple\"\n    }\n\n    # Create a grid of pie charts\n    fig = make_subplots(\n        rows=num_rows, cols=num_cols, \n        subplot_titles=[f\"{state} ({state_to_region[state]})\" for state in sorted_states], \n        specs=[[{\"type\": \"domain\"}] * num_cols] * num_rows\n    )\n\n    # Plot each state's pie chart\n    row, col = 1, 1\n    for state in sorted_states:\n        values = list(state_sex_data[state].values())\n        labels = list(state_sex_data[state].keys())\n        region = state_to_region[state]\n        color = region_colors.get(region, \"gray\")\n\n        fig.add_trace(\n            go.Pie(labels=labels, values=values, marker=dict(colors=[\"blue\", \"red\", \"gray\"]), \n                   showlegend=False, textinfo=\"percent\"),\n            row=row, col=col\n        )\n\n        # Update row and column for next plot\n        col += 1\n        if col &gt; num_cols:  # Move to the next row after 5 columns\n            col = 1\n            row += 1\n\n    # Update layout\n    fig.update_layout(\n        title_text=\"Distribuição de Estudantes por Sexo na Área Interdisciplinar por Estado\",\n        title_x=0.5,  # Center the title\n        title_y=0.98,  # Adjust title position slightly lower\n        margin=dict(t=250, b=50, l=50, r=50),  # Increase top margin for readability\n        height=max(num_rows * 300, 1200), width=1200  # Adjust height dynamically\n    )\n\n    # Show the plot\n    fig.show()\n\n⚠ No data available for Interdisciplinary area (45) per state."
  },
  {
    "objectID": "sucupira-preprocessamento.html",
    "href": "sucupira-preprocessamento.html",
    "title": "Pré-Processamento dos Dados da Plataforma Sucupira",
    "section": "",
    "text": "Os dados baixados da Plataforma Sucupira estão na forma de planilhas do Excel, e podem contar informações redundantes e desnecessárias para as análises que queremos fazer, além de necessitarem de organização para facilitar o processamento. Neste documento veremos como transformar as planilhas em bases de dados que facilitarão as análises.\nDependendo da análise existem várias formas de preprocessar os dados. Vamos primeiro ver como os dados são organizados nas planilhas para entender melhor as alternativas.\n\n\nAs planilhas dos anos anteriores contém todos os dados submetidos à Plataforma Sucupira, com uma planilha por ano, e com cada planilha representando categorias de dados submetidos à plataforma. Para os exemplos neste documento precisamos somente dos dados de produção científica, que estão armazenados em uma das abas da planilha. Uma cópia da tela da planilha (mostrando algumas de suas abas) e alguns registros sobre a de produção intelectual é mostrada abaixo.\n\nPodemos ver que a produção intelectual não é representada na planilha por um conjunto de linhas e colunas uniforme – os dados de uma produção intelectual estão distribuídos em várias linhas, algumas com pares de campos (detalhamentos da produção) em uma coluna para o nome e uma para o valor do detalhamento; e os nomes e categorias dos autores em colunas separadas. A imagem abaixo mostra o detalhamento de uma única produção contida nesta planilha.\n\nPara algumas das análises que queremos fazer precisamos ler as planilhas, filtrar todas as colunas desnecessárias e recuperar das múltiplas linhas por produção os dados que precisamos. O primeiro exemplo mostra como criar registros de contagem de autores e categorias por publicações, e o segundo exemplo mostra como criar registros de listas de autores por publicação.\n\n\n\nUsaremos Python para este preprocessamento. Primeiro importamos as bibliotecas necessárias:\n\nimport pandas as pd\nimport glob\nimport re\nimport warnings\nfrom IPython.display import Markdown"
  },
  {
    "objectID": "sucupira-preprocessamento.html#sobre",
    "href": "sucupira-preprocessamento.html#sobre",
    "title": "Pré-Processamento dos Dados da Plataforma Sucupira",
    "section": "",
    "text": "Os dados baixados da Plataforma Sucupira estão na forma de planilhas do Excel, e podem contar informações redundantes e desnecessárias para as análises que queremos fazer, além de necessitarem de organização para facilitar o processamento. Neste documento veremos como transformar as planilhas em bases de dados que facilitarão as análises.\nDependendo da análise existem várias formas de preprocessar os dados. Vamos primeiro ver como os dados são organizados nas planilhas para entender melhor as alternativas.\n\n\nAs planilhas dos anos anteriores contém todos os dados submetidos à Plataforma Sucupira, com uma planilha por ano, e com cada planilha representando categorias de dados submetidos à plataforma. Para os exemplos neste documento precisamos somente dos dados de produção científica, que estão armazenados em uma das abas da planilha. Uma cópia da tela da planilha (mostrando algumas de suas abas) e alguns registros sobre a de produção intelectual é mostrada abaixo.\n\nPodemos ver que a produção intelectual não é representada na planilha por um conjunto de linhas e colunas uniforme – os dados de uma produção intelectual estão distribuídos em várias linhas, algumas com pares de campos (detalhamentos da produção) em uma coluna para o nome e uma para o valor do detalhamento; e os nomes e categorias dos autores em colunas separadas. A imagem abaixo mostra o detalhamento de uma única produção contida nesta planilha.\n\nPara algumas das análises que queremos fazer precisamos ler as planilhas, filtrar todas as colunas desnecessárias e recuperar das múltiplas linhas por produção os dados que precisamos. O primeiro exemplo mostra como criar registros de contagem de autores e categorias por publicações, e o segundo exemplo mostra como criar registros de listas de autores por publicação.\n\n\n\nUsaremos Python para este preprocessamento. Primeiro importamos as bibliotecas necessárias:\n\nimport pandas as pd\nimport glob\nimport re\nimport warnings\nfrom IPython.display import Markdown"
  },
  {
    "objectID": "sucupira-preprocessamento.html#reorganizando-as-produções-intelectuais---contando-categorias-de-autores",
    "href": "sucupira-preprocessamento.html#reorganizando-as-produções-intelectuais---contando-categorias-de-autores",
    "title": "Pré-Processamento dos Dados da Plataforma Sucupira",
    "section": "Reorganizando as Produções Intelectuais - Contando Categorias de Autores",
    "text": "Reorganizando as Produções Intelectuais - Contando Categorias de Autores\nQueremos um conjunto de dados com uma publicação por registro e com contagem de autores por categorias. Para cada planilha vamos ler a aba Produção Intelectual, filtrar alguns campos que não são necessários e separar somente as linhas que tem nomes de autores. Como repetiremos estes passos para cada planilha é melhor definir uma função em Python que recebe o nome do arquivo e retorna um dataframe com os campos e linhas que precisamos:\n\ndef preprocessaProducoesParaCategorias(fileName):\n    # Lemos a planilha.\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, \n                                module=re.escape('openpyxl.styles.stylesheet'))\n        df = pd.read_excel(fileName,engine='openpyxl',sheet_name='Produção Intelectual')\n    # Removemos os campos indesejados.    \n    drop = ['Calendário', 'Ano do Calendário', \n            'Data-Hora do Envio','Código do PPG','Nome do PPG',\n            'Área de Avaliação','IES Sigla','IES Nome',\n            'Nome do Detalhamento','Valor do Detalhamento','Número de Ordem Autor'\n             ]\n    df = df.drop(columns=drop)\n    # Removemos os campos onde 'Nome do Autor' estiver vazio.\n    df = df.dropna(subset=['Nome do Autor'])\n    return df\n\nA biblioteca usada para a leitura de planilhas gera advertências no código, para isto usamos filtros de alertas (veja mais detalhes aqui).\nOs dados que precisamos estão todos armazenados em planilhas, uma por ano, em um diretório (a lista de planilhas para este documento pode ser vista aqui):\n\ndir = \"Resources/Data/ColetaSucupira/\"\n\nPodemos então criar uma lista de arquivos com nomes semelhantes no diretório indicado e uma lista de dataframes para receber os dados:\n\nfileNames = glob.glob(dir+\"relatorio_dados_enviados_coleta_20??.xlsx\")\ndfs = []\n\nAgora podemos ler cada um destes arquivos, filtrar linhas e colunas e anexar o dataframe filtrado à lista de dataframes:\n\nfor file in fileNames:\n    df = preprocessaProducoesParaCategorias(file)\n    dfs.append(df)\n\nEm uma linha concatenaremos todos os dataframes da produção intelectual do conjunto de planilhas:\n\ndfconcatenado = pd.concat(dfs, ignore_index=True)    \n\nDevemos manter somente as produções que não foram glosadas:\n\ndfconcatenado = dfconcatenado[dfconcatenado['Produção Glosada?'] == 'Não']\ndfconcatenado.drop(columns=['Produção Glosada?'], inplace=True)\n\nAgora temos todas as produções intelectuais de todos os anos que foram coletados na Plataforma Sucupira sobre nosso programa de pós-graduação. Mas estes dados ainda não estão prontos para a análise que queremos fazer: cada registro no dataframe contém informação sobre uma produção e um autor, portanto uma produção com quatro autores está representada em quatro registros.\nPodemos entender melhor este dataframe temporário criando um subconjunto dele contendo somente registros do artigo “A PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS”. Vamos também remover algumas colunas da amostra para facilitar a visualização):\n\ndfamostra = dfconcatenado.loc[dfconcatenado['Título da Produção'] == \n           'A PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS']\ndfamostra = dfamostra.drop(columns=['Área de Concentração','Linha de Pesquisa','Projeto de Pesquisa'])\n\nA amostra do dataframe pode ser visualizado com o código abaixo:\n\nMarkdown(dfamostra.to_markdown(index=False))\n\n\n\n\n\n\n\n\n\n\n\n\nAno da Produção\nTítulo da Produção\nTipo da Produção\nSubtipo da Produção\nNome do Autor\nCategoria do Autor\n\n\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nFABIANA ZIOTI\nEgresso - null\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nKARINE REIS FERREIRA GOMES\nDocente\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nGILBERTO RIBEIRO DE QUEIROZ\nDocente\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nALANA KASAHARA NEVES\nParticipante Externo\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nFELIPE MENINO CARLOS\nDiscente - Mestrado\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nFELIPE CARVALHO DE SOUZA\nEgresso - null\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nLORENA ALVES DOS SANTOS\nEgresso - null\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nROLF EZEQUIEL DE OLIVEIRA SIMOES\nEgresso - null\n\n\n\n\n\nA tabela acima mostra que os valores dos campos Título da Produção, Tipo da Produção e Subtipo da Produção são os mesmos para a produção. Cada autor da produção aparece em um registro do dataframe com sua categoria. O que precisamos, para esta análise, é saber para cada produção quantos autores de cada categoria temos. Para isto precisamos do código a seguir:\n\ndfProdAnter = dfamostra.pivot_table(index=['Ano da Produção', 'Título da Produção', \n                                           'Tipo da Produção', 'Subtipo da Produção'],\n                                           columns='Categoria do Autor',\n                                           values='Nome do Autor',\n                                           aggfunc='count',\n                                           fill_value=0).reset_index()\n\nO código acima cria um novo dataframe a partir da amostra usando como identificador único das produção uma combinação dos campos Ano da Produção, Título da Produção, Tipo da Produção e Subtipo da Produção; criando novos campos com os valores presentes na coluna Categoria do Autor e contando os nomes em cada categoria para cada identificador único. Campos com contagem inexistente serão preenchidos com zeros.\nPodemos visualizar o resultado na tabela abaixo.\n\nMarkdown(dfProdAnter.to_markdown(index=False))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAno da Produção\nTítulo da Produção\nTipo da Produção\nSubtipo da Produção\nDiscente - Mestrado\nDocente\nEgresso - null\nParticipante Externo\n\n\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\n1\n2\n4\n1\n\n\n\n\n\nCom o resultado comprovado podemos criar um dataframe que indica quantos autores por categoria para cada produção temos na base inteira.\n\ndfProdAnter = dfconcatenado.pivot_table(index=['Ano da Produção', 'Título da Produção', \n                                               'Tipo da Produção', 'Subtipo da Produção'],\n                                               columns='Categoria do Autor',\n                                               values='Nome do Autor',\n                                               aggfunc='count',\n                                               fill_value=0).reset_index()\n\nVamos renomear o campo Egresso - null, criado pelos procedimentos anteriores a partir dos valores do campo Categoria do Autor.\n\ndfProdAnter.rename(columns={'Egresso - null': 'Egresso'}, inplace=True)\n\nVamos também armazenar este dataframe em um arquivo para uso posterior.\n\ndfProdAnter.to_csv(dir+\"CategoriaDeAutoresPorProdução-AnosAnteriores.csv\",index=False)                                     \n\nVejamos os primeiros cinco registros deste novo dataframe:\n\nMarkdown(dfProdAnter.head(5).to_markdown(index=False))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAno da Produção\nTítulo da Produção\nTipo da Produção\nSubtipo da Produção\nDiscente - Doutorado\nDiscente - Mestrado\nDocente\nEgresso\nParticipante Externo\nPós-Doc\nSem Categoria\n\n\n\n\n2014\n‘MODELAGEM DE TURBULÊNCIA EM CAMADA LIMITE ATMOSFÉRICA / ATMOSPHERIC BOUNDARY LAYER TURBULENCE MODELLING’\nTÉCNICA\nAPRESENTAÇÃO DE TRABALHO\n0\n0\n1\n0\n0\n0\n0\n\n\n2014\n‘TURBULÊNCIA EM EVOLUÇÃO COSMOLÓGICA / TURBULENCE IN COSMOLOGICAL EVOLUTION’\nTÉCNICA\nAPRESENTAÇÃO DE TRABALHO\n0\n0\n1\n0\n0\n0\n0\n\n\n2014\n8TH BRAZILIAN WORKSHOP ON SYSTEMATIC AND AUTOMATED SOFTWARE TESTING (SAST 2014)\nTÉCNICA\nORGANIZAÇÃO DE EVENTO\n0\n0\n1\n0\n1\n0\n0\n\n\n2014\nA CLUSTERING SEARCH METAHEURISTIC FOR THE POINT-FEATURE CARTOGRAPHIC LABEL PLACEMENT PROBLEM\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\n0\n0\n1\n0\n3\n0\n0\n\n\n2014\nA CONSENSUS-BASED SEMI-SUPERVISED GROWING NEURAL GAS\nBIBLIOGRÁFICA\nTRABALHO EM ANAIS\n0\n0\n1\n0\n2\n0\n0\n\n\n\n\n\n\nComplementando com dados de produções do ano corrente\nA planilha com dados do ano corrente (o que está em preenchimento na Plataforma Sucupira ou que foi enviada no ano) tem um formato ligeiramente diferente do das planilhas dos anos já preenchidos. A figura a seguir mostra uma cópia da tela da planilha do ano corrente (no caso, 2023), mostrando os registros da produção intelectual.\n\nNesta planilha uma produção intelectual também é representada por um conjunto de linhas e colunas, com nomes e categorias de coautores em linhas separadas. A imagem abaixo mostra o detalhamento de uma única produção contida nesta planilha.\n\nNesta seção iremos formatar estes dados de forma a deixá-los compatíveis com os que foram coletados nos anos passados.\nDepois de baixar a planilha com dados do ano corrente e renomeá-la adequadamente podemos usar o código abaixo para ler a única aba (Produções - Autores) em um dataframe.\n\nfilename = \"ListaReplicadaComAutores2024.xlsx\"\nwith warnings.catch_warnings():\n     warnings.filterwarnings(\"ignore\", category=UserWarning, \n                             module=re.escape('openpyxl.styles.stylesheet'))\n     df = pd.read_excel(dir+filename,engine='openpyxl',sheet_name='Produções - Autores')\n\nPara eliminar as colunas do dataframe que não serão necessárias usamos o código a seguir:\n\nkeep = ['Ano da Produção','Nome da Produção','Tipo de Produção',\n        'Subtipo de Produção','Nome do Autor','Categoria do Autor']\ndf = df.drop(columns=[col for col in df.columns if col not in keep])\n\nOutro passo no processamento dos dados da planilha das produções do ano corrente é renomear algumas colunas para que fiquem compatíveis com as planilhas das produções dos anos anteriores.\n\ndf.rename(columns={'Nome da Produção': 'Título da Produção', \n                   'Tipo de Produção': 'Tipo da Produção', \n                   'Subtipo de Produção': 'Subtipo da Produção'}, inplace=True)\n\nPodemos reorganizar o dataframe para conter somente uma publicação por linha e com a contagem de autores por categorias com o código abaixo:\n\ndfProdAtual = df.pivot_table(index=['Ano da Produção', 'Título da Produção', \n                                    'Tipo da Produção', 'Subtipo da Produção'],\n                                    columns='Categoria do Autor',\n                                    values='Nome do Autor',\n                                    aggfunc='count',\n                                    fill_value=0).reset_index()\n\nFinalmente armazenamos este dataframe para uso posterior.\n\ndfProdAtual.to_csv(dir+\"CategoriaDeAutoresPorProdução-AnoCorrente.csv\",index=False)                                     \n\n\n\nUnificando as bases de dados de Produções Intelectuais\nNeste ponto temos duas bases de dados: CategoriaDeAutoresPorProdução-AnosAnteriores.csv e CategoriaDeAutoresPorProdução-AnoCorrente.csv. Embora as duas representem basicamente as mesmas informações, o formato é ligeiramente diferente na ordem das colunas e nos campos, que podem ser diferentes dependendo das categorias de coautores presentes nas planilhas originais. O código nesta seção ajusta e unifica os dados.\nA planilha com os dados de anos anteriores diferencia entre coautores de categorias Discente - Mestrado e Discente - Doutorado, mas a do ano atual não. Devemos então unificar as colunas Discente - Mestrado e Discente - Doutorado do dataframe contendo a produção intelectual dos anos anteriores, armazenando a soma na coluna nova Discente.\n\ndfProdAnter = dfProdAnter.assign(Discente=lambda x: x['Discente - Doutorado'] + x['Discente - Mestrado'])\ndfProdAnter = dfProdAnter.drop(columns=['Discente - Doutorado', 'Discente - Mestrado'])\n\nCom isto posso unificar os dataframes contendo a produção intelectual dos anos anteriores e a do ano atual. O dataframe resultante receberá todas as linhas e colunas dos dataframes unificados, e onde um campo não tiver correspondência preencheremos o seu valor com zero:\n\ncomuns = list(set(dfProdAnter.columns) & set(dfProdAtual.columns))\ndfProdUnificada = pd.merge(dfProdAnter, dfProdAtual, on=comuns, how='outer')\ndfProdUnificada.fillna(0, inplace=True)\n\nSalvamos também este dataframe para uso posterior.\n\ndfProdUnificada.to_csv(dir+\"CategoriaDeAutoresPorProdução-Unificada.csv\",index=False)"
  },
  {
    "objectID": "sucupira-preprocessamento.html#reorganizando-as-produções-intelectuais---autores-como-lista",
    "href": "sucupira-preprocessamento.html#reorganizando-as-produções-intelectuais---autores-como-lista",
    "title": "Pré-Processamento dos Dados da Plataforma Sucupira",
    "section": "Reorganizando as Produções Intelectuais - Autores como Lista",
    "text": "Reorganizando as Produções Intelectuais - Autores como Lista\nQueremos também obter um conjunto de dados com uma publicação por registro e com os nomes e categorias de autores representados como uma lista formatada como uma string. Para cada planilha vamos ler a aba Produção Intelectual e tratar as múltiplas linhas que contém informações sobre os autores e publicação para criar a nova estrutura.\nVamos também usar uma função em Python para fazer isto:\n\ndef preprocessaProducoesParaAutores(fileName):\n    # Lemos a planilha\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, \n                                module=re.escape('openpyxl.styles.stylesheet'))\n        df = pd.read_excel(fileName,engine='openpyxl',sheet_name='Produção Intelectual')    \n\n    # Criamos um dicionário para armazenar os dados estruturados. \n    publicacoes = {}\n\n    # Lemos cada linha da planilha para mapear para o dicionário.\n    for _, row in df.iterrows():\n        titulo = row[\"Título da Produção\"]\n        if pd.notna(titulo):\n            # Se é a primeira vez que vemos esta publicação...\n            if titulo not in publicacoes:\n                publicacoes[titulo] = {\n                    \"Ano da Produção\": row[\"Ano do Calendário\"],\n                    \"Título da Produção\": titulo, \n                    \"Glosada\": \"Não\", \n                    \"ISSN\": \"\",\n                    \"Título do Periódico\": \"\",                    \n                    \"DOI\": \"\",\n                    \"URL\": \"\",\n                    \"Tipo\": row[\"Tipo da Produção\"],\n                    \"Subtipo\": row[\"Subtipo da Produção\"],\n                    \"Idioma\": \"\",\n                    \"Autores\": [],\n                    \"Categorias\": []\n                }\n\n        # Atualiza metadados da publicação\n        if row[\"Nome do Detalhamento\"] == \"ISSN / Título do periódico\":\n            valores = row[\"Valor do Detalhamento\"].split(\"/\")\n            publicacoes[titulo][\"ISSN\"] = valores[0].strip() if len(valores) &gt; 0 else \"\"\n            publicacoes[titulo][\"Título do Periódico\"] = valores[1].strip() if len(valores) &gt; 1 else \"\"\n                \n        if row[\"Nome do Detalhamento\"] == \"Idioma\":\n            publicacoes[titulo][\"Idioma\"] = row[\"Valor do Detalhamento\"].strip()\n        \n        if row[\"Nome do Detalhamento\"] == \"Número do DOI\":\n            publicacoes[titulo][\"DOI\"] = row[\"Valor do Detalhamento\"].strip()            \n        \n        if row[\"Nome do Detalhamento\"] == \"URL\":\n            publicacoes[titulo][\"URL\"] = row[\"Valor do Detalhamento\"].strip()            \n        \n        # Verificamos se há alguma indicação de glosa\n        if \"glosa\" in str(row.to_dict()).lower():\n            publicacoes[titulo][\"Glosada\"] = \"Sim\"\n\n        # Se a linha contiver um autor, adiciona à lista da publicação correta\n        if pd.notna(row[\"Nome do Autor\"]):\n            publicacoes[titulo][\"Autores\"].append(row[\"Nome do Autor\"].strip())\n            publicacoes[titulo][\"Categorias\"].append(row[\"Categoria do Autor\"].strip())\n    \n    # Convertemos listas de autores e categorias para strings\n    for titulo in publicacoes:\n        publicacoes[titulo][\"Autores\"] = \" ; \".join(publicacoes[titulo][\"Autores\"])\n        publicacoes[titulo][\"Categorias\"] = \" ; \".join(publicacoes[titulo][\"Categorias\"])\n    \n    # Convertemos o dicionário para dataframe\n    df_final = pd.DataFrame(publicacoes.values())\n    return df_final\n\nAlgumas definições usadas no primeiro exemplo são repetidas aqui para maior clareza.\nPrimeiro criamos a lista de arquivos a serem lidos e uma lista de dataframes para receber os dados:\n\ndir = \"Resources/Data/ColetaSucupira/\"\nfileNames = glob.glob(dir+\"relatorio_dados_enviados_coleta_20??.xlsx\")\ndfs = []\n\nLemos cada um destes arquivos pela função que preprocessa e criamos um dataframe com uma linha para cada publicação:\n\nfor file in fileNames:\n    df = preprocessaProducoesParaAutores(file)\n    dfs.append(df)\n\nConcatenamos todos os dataframes criados:\n\ndfconcatenado = pd.concat(dfs, ignore_index=True)  \n\nPara verificar o dataframe vamos criar uma amostra contendo somente registros do artigo “A PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS”.\n\ndfamostra = dfconcatenado.loc[dfconcatenado['Título da Produção'] == \n           'A PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS']\n\nA visualização deve mostrar a estrutura esperada (uma publicação por linha; autores e categorias concatenados):\n\nMarkdown(dfamostra.to_markdown(index=False))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAno da Produção\nTítulo da Produção\nGlosada\nISSN\nTítulo do Periódico\nDOI\nURL\nTipo\nSubtipo\nIdioma\nAutores\nCategorias\n\n\n\n\n2022\nA PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS\nSim\n1569-8432\n(1569-8432) INTERNATIONAL JOURNAL OF APPLIED EARTH OBSERVATION AND GEOINFORMATION\n-\n[doi:10.1016/j.jag.2021.102655]\nBIBLIOGRÁFICA\nARTIGO EM PERIÓDICO\nINGLES\nFABIANA ZIOTI ; KARINE REIS FERREIRA GOMES ; GILBERTO RIBEIRO DE QUEIROZ ; ALANA KASAHARA NEVES ; FELIPE MENINO CARLOS ; FELIPE CARVALHO DE SOUZA ; LORENA ALVES DOS SANTOS ; ROLF EZEQUIEL DE OLIVEIRA SIMOES\nEgresso - null ; Docente ; Docente ; Participante Externo ; Discente - Mestrado ; Egresso - null ; Egresso - null ; Egresso - null\n\n\n\n\n\n\nComplementando com dados de produções do ano corrente\nA planilha com dados do ano corrente (o que está em preenchimento na Plataforma Sucupira ou que foi enviada no ano) tem um formato ligeiramente diferente do das planilhas dos anos já preenchidos. Comparando com as planilhas de anos passados, veremos que muitos campos não tem correspondência (por exemplo, Glosada, ISSN, DOI, URL, Idioma). Mesmo assim tentaremos ler esta planilha, com os dados que forem compatíveis com as dos anos anteriores.\nVamos criar uma função semelhante a preprocessaProducoesParaAutores para ler a planilha do ano atual. Esta função vai criar campos vazios, mas compatíveis com o dataframe retornado pela função preprocessaProducoesParaAutores:\n\ndef preprocessaProducoesParaAutores_Atual(fileName):\n    # Lemos a planilha\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, \n                                module=re.escape('openpyxl.styles.stylesheet'))\n        df = pd.read_excel(fileName,engine='openpyxl',sheet_name='Produções - Autores')  \n    \n    # Criar dicionário para armazenar os dados estruturados\n    producoes = {}\n    \n    for _, row in df.iterrows():\n        titulo = row[\"Nome da Produção\"]\n        \n        if pd.notna(titulo):\n            # Criar nova entrada se for um título novo\n            if titulo not in producoes:\n                producoes[titulo] = {\n                    \"Ano da Produção\": row[\"Ano da Produção\"],\n                    \"Título da Produção\": titulo, \n                    \"Glosada\": \"\", \n                    \"ISSN\": \"\",\n                    \"Título do Periódico\": \"\",                    \n                    \"DOI\": \"\",\n                    \"URL\": \"\",\n                    \"Tipo\": row[\"Tipo de Produção\"],\n                    \"Subtipo\": row[\"Subtipo de Produção\"],\n                    \"Idioma\": \"\",\n                    \"Autores\": [],\n                    \"Categorias\": []\n                }\n        \n        # Se a linha contiver um autor, adiciona à lista da produção correta\n        if pd.notna(row[\"Nome do Autor\"]):\n            producoes[titulo][\"Autores\"].append(row[\"Nome do Autor\"].strip())\n            producoes[titulo][\"Categorias\"].append(row[\"Categoria do Autor\"].strip())\n    \n    # Converter listas de autores e categorias para strings\n    for titulo in producoes:\n        producoes[titulo][\"Autores\"] = \"; \".join(producoes[titulo][\"Autores\"])\n        producoes[titulo][\"Categorias\"] = \"; \".join(producoes[titulo][\"Categorias\"])\n    \n    # Converter para DataFrame\n    df_final = pd.DataFrame(producoes.values())\n    return df_final\n\nCom esta função podemos ler a planilha com os dados do ano atual:\n\ndfAtual = preprocessaProducoesParaAutores_Atual(dir+\"ListaReplicadaComAutores2024.xlsx\")\n\nUnimos este novo dataframe ao já criado com as planilhas dos anos anteriores:\n\ndfUnificado = pd.concat([dfconcatenado, dfAtual], ignore_index=True)\n\nSalvamos em um arquivo local para uso posterior:\n\ndfUnificado.to_csv(dir+\"ProduçãoComListaDeAutores.csv\",index=False)"
  },
  {
    "objectID": "sucupira-tempotitulacao.html",
    "href": "sucupira-tempotitulacao.html",
    "title": "Análise Básica de Dados da Plataforma Sucupira - Tempo de Titulação",
    "section": "",
    "text": "Neste documento veremos como criar alguns gráficos sobre o tempo de titulação dos discentes do programa.\nNa seção Baixando os dados obtivemos vários dados da Plataforma Sucupira, inclusive dados sobre discentes. Os dados foram baixados de duas fontes diferentes na plataforma: planilhas com dados já homologados e a planilha do ano corrente. Como as duas fontes criam arquivos com estruturas diferentes precisamos unificá-las em um dataframe.",
    "crumbs": [
      "Dados do Coleta",
      "Tempo de Titulação"
    ]
  },
  {
    "objectID": "sucupira-tempotitulacao.html#sobre",
    "href": "sucupira-tempotitulacao.html#sobre",
    "title": "Análise Básica de Dados da Plataforma Sucupira - Tempo de Titulação",
    "section": "",
    "text": "Neste documento veremos como criar alguns gráficos sobre o tempo de titulação dos discentes do programa.\nNa seção Baixando os dados obtivemos vários dados da Plataforma Sucupira, inclusive dados sobre discentes. Os dados foram baixados de duas fontes diferentes na plataforma: planilhas com dados já homologados e a planilha do ano corrente. Como as duas fontes criam arquivos com estruturas diferentes precisamos unificá-las em um dataframe.",
    "crumbs": [
      "Dados do Coleta",
      "Tempo de Titulação"
    ]
  },
  {
    "objectID": "sucupira-tempotitulacao.html#unificando-os-dados",
    "href": "sucupira-tempotitulacao.html#unificando-os-dados",
    "title": "Análise Básica de Dados da Plataforma Sucupira - Tempo de Titulação",
    "section": "Unificando os dados",
    "text": "Unificando os dados\nAntes de iniciar o processamento de dados para unificação das planilhas vamos importar as bibliotecas necessárias:\n\nimport pandas as pd\nimport glob\nimport re\nimport warnings\nfrom datetime import datetime\nimport plotly.graph_objs as go\nimport plotly.express as px\nimport plotly.colors as pc\n\nOs dados sobre os discentes de cada ano estão nas abas Discentes das planilhas baixadas anteriormente. A figura abaixo mostra a aba, com alguns campos expandidos:\n\nPodemos ver que dados dos discentes podem ocupar mais de uma linha na planilha, caso tenham mais de um orientador e/ou mais de uma situação no ano da coleta. Como queremos somente os dados de alunos cuja Situação Discente seja igual a TITULADO basta considerar somente estas linhas das planilhas e remover as duplicadas (que ocorrerão quando tivermos mais de um orientador).\n\ndef preprocessaDiscentesTitulados(arquivo):\n    # Lemos a planilha\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, \n                                module=re.escape('openpyxl.styles.stylesheet'))\n        df = pd.read_excel(arquivo,engine='openpyxl',sheet_name='Discentes')  \n    # Definimos as colunas de interesse.\n    colunas = [\n        \"Ano do Calendário\",\n        \"Nome Discente\", \n        \"Nível Discente\", \n        \"Situação Discente\", \n        \"Data Matrícula\", \n        \"Data Titulação\"\n    ]\n    # Filtramos pelas colunas.\n    df = df[colunas]\n    # Garantimos que estes campos serão datas:\n    df[\"Data Matrícula\"] = pd.to_datetime(df[\"Data Matrícula\"], format=\"%d/%m/%Y\")\n    df[\"Data Titulação\"] = pd.to_datetime(df[\"Data Titulação\"], format=\"%d/%m/%Y\")\n    # Filtramos por 'TITULADO'\n    df_filtered = df[df[\"Situação Discente\"] == \"TITULADO\"]    \n    # Removemos duplicatas\n    df_filtered = df_filtered.drop_duplicates(subset=colunas, keep='first')\n    return df_filtered\n\n\nAs abas Discentes das planilhas de anos anteriores ao atual tem outras informações que podem ser interessantes para análise de discentes por gênero e raça. Ignoraremos estes dados pois os mesmos não estão disponíveis na planilha do ano corrente.\n\nCom isto podemos criar um dataframe com todas as planilhas de anos anteriores:\n\ndir = \"Resources/Data/ColetaSucupira/\"\nfileNames = glob.glob(dir+\"relatorio_dados_enviados_coleta_20??.xlsx\")\ndfs = []\nfor file in fileNames:\n    df = preprocessaDiscentesTitulados(file)\n    dfs.append(df)\ndfconcatenado = pd.concat(dfs, ignore_index=True)   \n\nVamos ver parte do dataframe:\n\ndfconcatenado\n\n\n\n\n\n\n\n\n\nAno do Calendário\nNome Discente\nNível Discente\nSituação Discente\nData Matrícula\nData Titulação\n\n\n\n\n0\n2015\nFELIPE RODOLFO SANTOS CORREA\nMestrado\nTITULADO\n2012-03-01\n2015-05-12\n\n\n1\n2015\nGUSTAVO FURTADO DE OLIVEIRA ALVES\nMestrado\nTITULADO\n2012-03-01\n2015-05-14\n\n\n2\n2015\nJULIANA APARECIDA ANOCHI\nDoutorado\nTITULADO\n2010-12-01\n2015-11-03\n\n\n3\n2015\nLUCIANA BRASIL REBELO DOS SANTOS\nDoutorado\nTITULADO\n2010-09-01\n2015-10-02\n\n\n4\n2015\nMANOEL BAPTISTA DA SILVA JUNIOR\nMestrado\nTITULADO\n2012-06-01\n2015-05-29\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n134\n2016\nLUIS FERNANDO AMORIM FRANCA\nDoutorado\nTITULADO\n2011-03-01\n2016-05-16\n\n\n135\n2016\nMARIA EUGENIA SAUSEN WELTER\nMestrado\nTITULADO\n2013-04-12\n2016-05-27\n\n\n136\n2016\nMARILYN MENECUCCI IBANEZ\nDoutorado\nTITULADO\n2016-02-13\n2016-02-19\n\n\n137\n2016\nMARLUCE DA CRUZ SCARABELLO\nDoutorado\nTITULADO\n2012-06-01\n2016-09-01\n\n\n138\n2016\nVANDER LUIS DE SOUZA FREITAS\nDoutorado\nTITULADO\n2016-03-03\n2016-03-03\n\n\n\n\n139 rows × 6 columns\n\n\n\n\nJá é possível observar alguns erros de preenchimento, que serão processados posteriormente.\nComo queremos também usar os dados da planilha do ano corrente precisamos importá-la, filtrar os dados e converter em um dataframe para unificação (mantendo os mesmos campos). Mas a planilha dos dados do ano corrente tem algumas diferenças: como mostrado na seção Baixando os dados a planilha tem somente uma aba (Discentes - Orientadores), não apresenta o ano do calendário e tem um campo Data Situação em vez de Data Titulação, comforme mostrado na figura a seguir.\n\nPrecisaremos de uma função modificada para ler esta planilha para unificá-la com os dados dos anos passados:\n\ndef preprocessaDiscentesTituladosAnoAtual(arquivo,ano_calendario):\n    # Lemos a planilha\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, \n                                module=re.escape('openpyxl.styles.stylesheet'))\n        df = pd.read_excel(arquivo,engine='openpyxl',sheet_name='Discentes - Orientadores')  \n    # Definimos as colunas de interesse.\n    colunas = [\n        \"Nome Discente\", \n        \"Nível Discente\", \n        \"Situação Discente\", \n        \"Data Matrícula\", \n        \"Data Situação\" # Campo com nome diferente!\n    ]\n    # Filtramos pelas colunas.\n    df = df[colunas]\n    # Indicamos o ano do calendário explicitamente.\n    df[\"Ano do Calendário\"] = ano_calendario\n    # Garantimos que estes campos serão datas:\n    df[\"Data Matrícula\"] = pd.to_datetime(df[\"Data Matrícula\"], format=\"%d/%m/%Y\")\n    df[\"Data Situação\"] = pd.to_datetime(df[\"Data Situação\"], format=\"%d/%m/%Y\")\n    # Filtramos por 'TITULADO'\n    df_filtered = df[df[\"Situação Discente\"] == \"TITULADO\"]    \n    # Removemos duplicatas\n    df_filtered = df_filtered.drop_duplicates(subset=colunas, keep='first')\n    # Renomeamos 'Data Situação' para 'Data Titulação'\n    df_filtered.rename(columns={\"Data Situação\": \"Data Titulação\"}, inplace=True)\n    return df_filtered\n\nTodos os dataframes podem ser unificados com:\n\narquivo = dir+\"Discentes2024.xlsx\"\ndfAnoAtual = preprocessaDiscentesTituladosAnoAtual(arquivo,2024)\ndf = pd.concat([dfconcatenado, dfAnoAtual], ignore_index=True)",
    "crumbs": [
      "Dados do Coleta",
      "Tempo de Titulação"
    ]
  },
  {
    "objectID": "sucupira-tempotitulacao.html#pequenas-correções",
    "href": "sucupira-tempotitulacao.html#pequenas-correções",
    "title": "Análise Básica de Dados da Plataforma Sucupira - Tempo de Titulação",
    "section": "Pequenas correções",
    "text": "Pequenas correções\nUma rápida vista nos dados importados mostra que existem alguns erros de preenchimento que acabaram passando para as planilhas. Os mais óbvios são sobre as datas de matrícula, que em alguns casos tem o mesmo ano que as datas de titulação. Verifiquemos com uma contagem mais flexível, que indica quantos mestres se formaram em menos de 18 meses e quantos doutores em menos de 24:\n\ndf[\"Tempo de Titulação (meses)\"] = (df[\"Data Titulação\"] - df[\"Data Matrícula\"]).dt.days / 30\n# Contamos casos suspeitos:\nmMin = 18\ndMin = 24\nmErro = df[(df[\"Nível Discente\"] == \"Mestrado\") & (df[\"Tempo de Titulação (meses)\"] &lt; mMin)].shape[0]\ndErro = df[(df[\"Nível Discente\"] == \"Doutorado\") & (df[\"Tempo de Titulação (meses)\"] &lt; dMin)].shape[0]\nmErro,dErro\n\n(0, 2)\n\n\nPodemos descartar os dados suspeitos com estas linhas:\n\ndfOK = df[\n    ~(\n        ((df[\"Nível Discente\"] == \"Mestrado\") & (df[\"Tempo de Titulação (meses)\"] &lt; mMin)) |\n        ((df[\"Nível Discente\"] == \"Doutorado\") & (df[\"Tempo de Titulação (meses)\"] &lt; dMin))\n    )\n]\n\nPodemos armazenar este dataframe em um arquivo para outros usos:\n\ndfOK.to_csv(dir+\"Discentes-TempoDeTitulacao.csv\",index=False)",
    "crumbs": [
      "Dados do Coleta",
      "Tempo de Titulação"
    ]
  },
  {
    "objectID": "sucupira-tempotitulacao.html#análise-exploratória-de-dados",
    "href": "sucupira-tempotitulacao.html#análise-exploratória-de-dados",
    "title": "Análise Básica de Dados da Plataforma Sucupira - Tempo de Titulação",
    "section": "Análise Exploratória de Dados",
    "text": "Análise Exploratória de Dados\nVamos ver duas séries de boxplots, uma para o mestrado:\n\ndf_mes = dfOK[dfOK[\"Nível Discente\"] == \"Mestrado\"]\ncount_mes = df_mes[\"Ano do Calendário\"].value_counts().sort_index()\n# Criamos o box plot para Mestrado\nfig = px.box(df_mes, \n             x=\"Ano do Calendário\", \n             y=\"Tempo de Titulação (meses)\", \n             title=\"Distribuição do Tempo de Titulação - Mestrado\",\n             labels={\"Tempo de Titulação (meses)\": \"Tempo de Titulação (meses)\", \n                     \"Ano do Calendário\": \"Ano\"},\n             color_discrete_sequence=[\"#F3801B\"])\n# Adiciono linhas para os prazos.\nfig.add_hline(y=24, line_color=\"blue\", annotation_text=\"24 meses\", annotation_position=\"top left\")\nfig.add_hline(y=36, line_color=\"red\", annotation_text=\"36 meses\", annotation_position=\"top left\")\n# Ajusto para o eixo Y iniciar de zero.\nmax_y_mes = df_mes[\"Tempo de Titulação (meses)\"].max() + 6\nfig.update_yaxes(range=[0, max_y_mes])\n# Adicionamos número de titulados por ano no gráfico de Mestrado\nfor ano, count in count_mes.items():\n    fig.add_annotation(x=ano, y=max_y_mes-3, text=f\"{count} titulados\", \n                       showarrow=False, font=dict(size=12, color=\"black\"))\nfig.show()                                                 \n\n                                                \n\n\nE uma para o doutorado:\n\ndf_dou = dfOK[dfOK[\"Nível Discente\"] == \"Doutorado\"]\ncount_dou = df_dou[\"Ano do Calendário\"].value_counts().sort_index()\nanos_ordenados = sorted(df_dou[\"Ano do Calendário\"].unique())\n# Criamos o box plot para Doutorado\nfig = px.box(df_dou, \n             x=\"Ano do Calendário\", \n             y=\"Tempo de Titulação (meses)\", \n             title=\"Distribuição do Tempo de Titulação - Doutorado\",\n             labels={\"Tempo de Titulação (meses)\": \"Tempo de Titulação (meses)\", \n                     \"Ano do Calendário\": \"Ano\"},\n             color_discrete_sequence=[\"#1268AF\"])\n# Adiciono linhas para os prazos.\nfig.add_hline(y=36, line_color=\"blue\", annotation_text=\"36 meses\", annotation_position=\"top left\")\nfig.add_hline(y=60, line_color=\"red\", annotation_text=\"60 meses\", annotation_position=\"top left\")\n# Ajusto para o eixo Y iniciar de zero.\nmax_y_dou = df_dou[\"Tempo de Titulação (meses)\"].max() + 6\nfig.update_yaxes(range=[0, max_y_dou])\nfig.update_xaxes(dtick=1)\n# Adicionamos número de titulados por ano no gráfico de Doutorado\nfor ano, count in count_dou.items():\n    fig.add_annotation(x=ano, y=max_y_dou-3, text=f\"{count} titulados\", \n                       showarrow=False, font=dict(size=12, color=\"black\"))\nfig.show()",
    "crumbs": [
      "Dados do Coleta",
      "Tempo de Titulação"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análise de Dados da CAPES",
    "section": "",
    "text": "Este conjunto de documentos contém instruções, exemplos, scripts, etc. para acessar dados da CAPES, em particular dados de interesse de coordenadores de programas de pós-graduação e gestores.\nEstá em desenvolvimento (em 2024), mas resolvi publicar alguns exemplos que já podem ser úteis para alguns colegas.\nAlgumas observações sobre estes documentos:\n\nDou mais ênfase a reprodutibilidade e simplicidade do código do que a eficiência.\nOnde possível detalhei como obter os dados, mas em alguns casos as fontes de dados só podem ser acessadas por coordenadores de programas (ex. via plataforma Sucupira).\nNão posso garantir que os exemplos e códigos vão funcionar sempre, mas como este é um notebook o código que aparece nele foi executado para mostrar os resultados – ao menos uma vez funcionou!\nVeja na barra à esquerda o que já está pronto.\n\nEste material foi preparando usando Quarto, com código em Python, usando Visual Studio Code como ambiente de desenvolviumento integrado.\n\n\nSe seu interesse são nas análises já prontas (por exemplo, para usar os gráficos já preparados feitos com os dados abertos da Plataforma Sucupira) pule as páginas cujos títulos iniciam com Baixando ou Pré-Processamento. Estas páginas mostram como baixar os dados das fontes originais e preparar estes dados para os relatórios e gráficos, e são úteis para reproduzir e ampliar os escopos das análises.\nSe você quer reproduzir alguns dos exemplos usando informações de seu interesse (por exemplo, de seu programa, IES/ICT, área, região geográfica, etc.) copie o código em Python relevante – está razoavelmente documentado. Verifique antes as dependências de dados preprocessados – também estão documentadas, provavelmente nas páginas cujos títulos iniciam com Baixando ou Pré-Processamento.\nEm caso de dúvida entre em contato (veja link no rodapé das páginas). Não posso garantir respostas rápidas mas tentarei responder todas as mensagens.",
    "crumbs": [
      "Sobre"
    ]
  },
  {
    "objectID": "index.html#sobre",
    "href": "index.html#sobre",
    "title": "Análise de Dados da CAPES",
    "section": "",
    "text": "Este conjunto de documentos contém instruções, exemplos, scripts, etc. para acessar dados da CAPES, em particular dados de interesse de coordenadores de programas de pós-graduação e gestores.\nEstá em desenvolvimento (em 2024), mas resolvi publicar alguns exemplos que já podem ser úteis para alguns colegas.\nAlgumas observações sobre estes documentos:\n\nDou mais ênfase a reprodutibilidade e simplicidade do código do que a eficiência.\nOnde possível detalhei como obter os dados, mas em alguns casos as fontes de dados só podem ser acessadas por coordenadores de programas (ex. via plataforma Sucupira).\nNão posso garantir que os exemplos e códigos vão funcionar sempre, mas como este é um notebook o código que aparece nele foi executado para mostrar os resultados – ao menos uma vez funcionou!\nVeja na barra à esquerda o que já está pronto.\n\nEste material foi preparando usando Quarto, com código em Python, usando Visual Studio Code como ambiente de desenvolviumento integrado.\n\n\nSe seu interesse são nas análises já prontas (por exemplo, para usar os gráficos já preparados feitos com os dados abertos da Plataforma Sucupira) pule as páginas cujos títulos iniciam com Baixando ou Pré-Processamento. Estas páginas mostram como baixar os dados das fontes originais e preparar estes dados para os relatórios e gráficos, e são úteis para reproduzir e ampliar os escopos das análises.\nSe você quer reproduzir alguns dos exemplos usando informações de seu interesse (por exemplo, de seu programa, IES/ICT, área, região geográfica, etc.) copie o código em Python relevante – está razoavelmente documentado. Verifique antes as dependências de dados preprocessados – também estão documentadas, provavelmente nas páginas cujos títulos iniciam com Baixando ou Pré-Processamento.\nEm caso de dúvida entre em contato (veja link no rodapé das páginas). Não posso garantir respostas rápidas mas tentarei responder todas as mensagens.",
    "crumbs": [
      "Sobre"
    ]
  },
  {
    "objectID": "index.html#glossário",
    "href": "index.html#glossário",
    "title": "Análise de Dados da CAPES",
    "section": "Glossário",
    "text": "Glossário\n\nCAPES\n\nA Coordenação de Aperfeiçoamento de Pessoal de Nível Superior é uma Fundação do Ministério da Educação (MEC) que tem como missão a expansão e consolidação da pós-graduação stricto sensu (mestrado e doutorado) e formação de professores da educação básica no Brasil.\n\nSucupira (Plataforma Sucupira)\n\nA Plataforma Sucupira é um conjunto de ferramentas para coleta, análise e disseminação de dados dos programas de pós-graduação do Brasil, apoiando o Sistema Nacional de Pós-Graduação (SNPG). Algumas de suas funções são o módulo de envio de dados dos programas de pós-graduação (Coleta) e o catálogo de periódicos avaliados (Qualis). A nova versão da plataforma permite consultas detalhadas aos dados submetidos.",
    "crumbs": [
      "Sobre"
    ]
  },
  {
    "objectID": "index.html#alternativas",
    "href": "index.html#alternativas",
    "title": "Análise de Dados da CAPES",
    "section": "Alternativas",
    "text": "Alternativas\nSe seu objetivo é analisar dados da CAPES, em especial de programas de pós-graduação, existem várias alternativas que não envolvem programação e/ou cópias locais das bases de dados. Algumas são:\n\nA nova versão da Plataforma Sucupira que contém relatórios sobre cursos avaliados e reconhecidos e o Observatório da Pós-graduação.\nO Sistema Tarrafa, desenvolvido pela Unimontes – Universidade Estadual de Montes Claros, que usa dados da CAPES e CNPq para criar relatórios complexos e comparativos entre programas de pós-graduação.",
    "crumbs": [
      "Sobre"
    ]
  },
  {
    "objectID": "sucupira-baixando.html",
    "href": "sucupira-baixando.html",
    "title": "Obtendo dados submetidos à Plataforma Sucupira",
    "section": "",
    "text": "Atenção!\n\n\n\nEsta seção trata de dados que só podem ser obtidos da Plataforma Sucupira com credenciais de coordenador de programa de pós-graduação!",
    "crumbs": [
      "Dados do Coleta",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "sucupira-baixando.html#como-obter-os-dados",
    "href": "sucupira-baixando.html#como-obter-os-dados",
    "title": "Obtendo dados submetidos à Plataforma Sucupira",
    "section": "Como obter os dados",
    "text": "Como obter os dados\nPara as análises nesta seção usaremos os dados submetidos à Plataforma Sucupira (não os dados abertos da CAPES, que serão usados em outra seção), mas somente os dados de um determinado programa de pós-graduação. Estes dados podem ser obtidos no próprio módulo de coleta de dados, acessível somente por coordenadores deste programa e pessoas autorizadas.\nPara obter estes dados é necessário entrar na Plataforma Sucupira e clique em ACESSO RESTRITO, depois no ícone do Portal do Coordenador de PPG.\nOs dados que já foram enviados pela plataforma e homologados pelas pró-reitorias podem ser baixados na forma de planilhas. Use o menu Coleta Online/Relatórios/Dados Enviados do Coleta conforme mostrado na imagem a seguir.\n\nO portal mostrará opções para selecionar o ano de envio dos dados, opções para escolher quais categorias de dados devem ser baixados e o formato como mostrado a seguir.\n\nEscolha o ano, selecione todos os dados e escolha XLS como formato de exportação. Clique em Gerar Relatório e aguarde alguns segundos par ver o link para obtenção do arquivo. Repita esta operação para cada ano que quiser analisar, renomeando o arquivo baixado.\n\nArquivos baixados neste exemplo\nPara os exemplos usados nestes documentos a lista de arquivos, já renomeada, é:\nrelatorio_dados_enviados_coleta_2014.xlsx\nrelatorio_dados_enviados_coleta_2015.xlsx\nrelatorio_dados_enviados_coleta_2016.xlsx\nrelatorio_dados_enviados_coleta_2017.xlsx\nrelatorio_dados_enviados_coleta_2018.xlsx\nrelatorio_dados_enviados_coleta_2019.xlsx\nrelatorio_dados_enviados_coleta_2020.xlsx\nrelatorio_dados_enviados_coleta_2021.xlsx\nrelatorio_dados_enviados_coleta_2022.xlsx\nrelatorio_dados_enviados_coleta_2023.xlsx\n\n\nDados do preenchimento do ano corrente - Produção Intelectual\nAs planilhas baixadas através do procedimento mostrado na seção anterior contém dados que já foram enviados para a CAPES, mas não os dados sendo preenchidos no ano corrente. Se for necessário baixar alguns dos dados do preenchimento podemos fazê-lo para algumas categorias.\nÉ importante observar que a planilha com dados do ano corrente tem formato e conteúdo diferente das planilhas dos anos já homologados.\nComo veremos alguns exemplos de análise de publicações vamos baixar a planilha de publicações do ano corrente. Acesse, no Portal do Coordenador de PPG da Plataforma Sucupira, o menu Coleta Online/Relatórios/Conferência do Programa, como ilustrado na figura abaixo:\n\nPara baixar a planilha com dados de publicações do ano corrente (claro, somente com as que o coordenador tiver importado ou cadastrado na Plataforma Sucupira) selecione a categoria Produção Intelectual, use como Ano de Referência o ano corrente, selecione a opção de exportar relatório para XLS e como tipo de relatório selecione Lista replicada de produções intelectuais com informação de autores – esta será a opção mais adequada para os relatórios deste estudo. As opções sugeridas são mostradas na figura abaixo.\n\nClique em Gerar Relatório e aguarde o link para baixar a planilha. Renomeie-a para ListaReplicadaComAutores2024.xlsx (2024 sendo o ano corrente).\n\n\nDados do preenchimento do ano corrente - Discentes\nVamos também baixar a planilha com dados dos discentes do ano corrente (que ainda não foram enviados para o Coleta). No Portal do Coordenador de PPG da Plataforma Sucupira, o menu Coleta Online/Relatórios/Conferência do Programa, selecione a categoria Discente, use como Ano de Referência o ano corrente, selecione a opção de exportar relatório para XLS e como tipo de relatório selecione Lista replicada de discente, com informação de Orientador(es).\nClique em Gerar Relatório e aguarde o link para baixar a planilha. Renomeie-a para Discentes2024.xlsx (2024 sendo o ano corrente).\n\n\n\n\n\n\nNota\n\n\n\nÉ possível obter esta planilha mesmo após a submissão e homologação do Coleta do ano de referência.",
    "crumbs": [
      "Dados do Coleta",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-docentes.html",
    "href": "dadosabertos-comparativo-idade-docentes.html",
    "title": "Idade dos Docentes dos Programas de Pós-Graduação",
    "section": "",
    "text": "Este documento apresenta código e procedimentos para criar gráficos e análises comparativas sobre a idade dos docentes dos programas de pós-graduação.",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Docentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-docentes.html#sobre",
    "href": "dadosabertos-comparativo-idade-docentes.html#sobre",
    "title": "Idade dos Docentes dos Programas de Pós-Graduação",
    "section": "",
    "text": "Este documento apresenta código e procedimentos para criar gráficos e análises comparativas sobre a idade dos docentes dos programas de pós-graduação.",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Docentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-docentes.html#obtendo-os-dados",
    "href": "dadosabertos-comparativo-idade-docentes.html#obtendo-os-dados",
    "title": "Idade dos Docentes dos Programas de Pós-Graduação",
    "section": "Obtendo os dados",
    "text": "Obtendo os dados\nPrimeiro verifique na seção Dados sobre Docentes da Pós-Graduação Stricto Sensu no Brasil como baixar as planilhas com dados de docentes. Para os exemplos neste documento usaremos o arquivo br-capes-colsucup-docente-2022-2023-11-30.xlsx (versão mais atual quando o documento foi criado).\n\n\n\n\n\n\nAtenção\n\n\n\nOs dados usados neste documento são de 2022.",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Docentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-docentes.html#lendo-e-filtrando-os-dados",
    "href": "dadosabertos-comparativo-idade-docentes.html#lendo-e-filtrando-os-dados",
    "title": "Idade dos Docentes dos Programas de Pós-Graduação",
    "section": "Lendo e filtrando os dados",
    "text": "Lendo e filtrando os dados\nVamos obter um dataframe com os dados da planilha br-capes-colsucup-docente-2022-2023-11-30.xlsx, mantendo somente as colunas relevantes para os gráficos neste documento. Primeiro importamos as bibliotecas necessárias:\n\nimport pandas as pd\nimport re\nimport warnings\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime\n\nPara facilitar a modificação do código para gerar gráficos comparando programas, regiões, áreas de avaliação e entidades de ensino vamos definir algumas constantes para filtrar os dados depois de lidos.\n\narquivo = 'Resources/Data/DadosAbertos/br-capes-colsucup-docente-2022-2023-11-30.xlsx'\nprograma = '33010013002P1' # COMPUTAÇÃO APLICADA\nentidade = 33010013 # INSTITUTO NACIONAL DE PESQUISAS ESPACIAIS\nuf = 'SP'\nregião = 'SUDESTE'\nárea_de_avaliação = 45 # Interdisciplinar\n\nAgora podemos ler a planilha, selecionar e ajustar colunas se necessário:\n\n# Lemos a planilha ignorando avisos.\nwith warnings.catch_warnings():\n    warnings.filterwarnings(\"ignore\", category=UserWarning, \n                            module=re.escape('openpyxl.styles.stylesheet'))\n    df = pd.read_excel(arquivo,engine='openpyxl')\n    # Removemos os campos indesejados (especialmente as identificações dos docentes).    \n    keep = ['CD_AREA_AVALIACAO', 'NM_AREA_AVALIACAO', 'CD_PROGRAMA_IES', 'NM_PROGRAMA_IES',\n            'CD_CONCEITO_PROGRAMA', 'CD_ENTIDADE_CAPES', \n            'SG_ENTIDADE_ENSINO', 'NM_ENTIDADE_ENSINO', \n            'SG_UF_PROGRAMA', 'NM_REGIAO', 'ID_PESSOA', 'AN_NASCIMENTO_DOCENTE', 'AN_TITULACAO'\n             ]\n    df = df[keep]",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Docentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-docentes.html#gráficos",
    "href": "dadosabertos-comparativo-idade-docentes.html#gráficos",
    "title": "Idade dos Docentes dos Programas de Pós-Graduação",
    "section": "Gráficos",
    "text": "Gráficos\nCom os dados lidos e preprocessados podemos aplicar filtros e criar os gráficos. Os passos envolvem selecionar parte do dataframe, criar um histograma e exibir este histograma em um gráfico.\nO dataframe original contém uma coluna, DS_FAIXA_ETARIA, que já representa a faixa etária dos docentes, mas criaremos um novo histograma a partir do ano de nascimento para ficar mais atual e flexível.\nO passo de criação do histograma pode ser feito através de uma função que já pode ser definida como:\n\ndef dataframe_para_histograma(df_filtrado):\n    ano_atual = datetime.now().year\n    # Calculamos a idade das pessoas.\n    df_filtrado['Idade'] = ano_atual - df_filtrado['AN_NASCIMENTO_DOCENTE']    \n    # Usamos faixas de 5 anos dos 20 aos 75 anos, e uma faixa final para mais de 75 anos.\n    faixas = [20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 120]  \n    rotulos_faixas = [f'{i}-{i+5}' for i in range(20, 75, 5)] + ['75+']  \n    # Categorizamos as idades nas faixas.\n    df_filtrado['Faixa de Idade'] = pd.cut(df_filtrado['Idade'], bins=faixas, \n                                           labels=rotulos_faixas, right=False)\n    # Contamos o número de pessoas por faixa.\n    histo = df_filtrado['Faixa de Idade'].value_counts().reindex(rotulos_faixas, fill_value=0)\n    # Criamos um dataframe com o histograma. Cada faixa terá o rótulo, valores e índice.\n    df_histo = pd.DataFrame({\n        'Faixa de Idade': pd.Categorical(histo.index, categories=rotulos_faixas, ordered=True),\n        'Número': histo.values,\n        'Posição': range(len(rotulos_faixas)) \n    })\n    return df_histo, rotulos_faixas\n\nTambém podemos definir uma função que cria um gráfico com o histograma, assim garantimos uma consistência visual em gráficos semelhantes:\n\ndef cria_gráfico_histograma(df_histo,título):\n    fig = px.bar(df_histo, x='Faixa de Idade', y='Número',\n                 title=título, \n                 category_orders={'Faixa de Idade': rotulos_faixas},\n                 color='Posição',  \n                 color_continuous_scale='Rainbow')\n    fig.update_layout(coloraxis_showscale=False)     \n    fig.update_yaxes(title_text='')      \n    return fig\n\n\nDistribuição da idade dos docentes do programa\nVamos ver a distribuição de idades dos docentes de um programa. Primeiro filtramos o dataframe:\n\nnome_do_programa = df.loc[df['CD_PROGRAMA_IES'] == programa, 'NM_PROGRAMA_IES'].values[0]\nsigla_ies = df.loc[df['CD_PROGRAMA_IES'] == programa, 'SG_ENTIDADE_ENSINO'].values[0]\ndf_filtrado = df[df['CD_PROGRAMA_IES'] == programa].copy()\n\nUsamos a função para calcular o histograma das idades:\n\ndf_histo, rotulos_faixas = dataframe_para_histograma(df_filtrado)\n\nE plotamos a distribuição em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Docentes para {nome_do_programa} - {sigla_ies}'\nfig = cria_gráfico_histograma(df_histo,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos docentes da IES\nUsando este primeiro exemplo podemos facilmente criar gráficos sobre outros filtros do dataframe original. Este é sobre a idade dos docentes da institução.\n\nnome_da_entidade = df.loc[df['CD_ENTIDADE_CAPES'] == entidade, 'NM_ENTIDADE_ENSINO'].values[0]\ndf_filtrado = df[df['CD_ENTIDADE_CAPES'] == entidade].copy()\n\nUsamos a função para calcular o histograma das idades:\n\ndf_histo, rotulos_faixas = dataframe_para_histograma(df_filtrado)\n\nE plotamos a distribuição em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Docentes para {nome_da_entidade}'\nfig = cria_gráfico_histograma(df_histo,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos docentes de uma determinada área de avaliação\nVejamos agora como filtrar os docentes de programas vinculados a uma área de avaliação:\n\nnome_da_área = df.loc[df['CD_AREA_AVALIACAO'] == área_de_avaliação, 'NM_AREA_AVALIACAO'].values[0]\ndf_filtrado = df[df['CD_AREA_AVALIACAO'] == área_de_avaliação].copy()\n\nUsamos a função para calcular o histograma das idades:\n\ndf_histo, rotulos_faixas = dataframe_para_histograma(df_filtrado)\n\nE plotamos a distribuição em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Docentes na área {nome_da_área}'\nfig = cria_gráfico_histograma(df_histo,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos docentes de todos os programas\nComo comparativo vamos ver a distribuição da idade de todos os docentes de todos os programas.\nUsamos a função para calcular o histograma das idades, usando o dataframe original sem filtros:\n\ndf_histo, rotulos_faixas = dataframe_para_histograma(df)\n\nE plotamos a distribuição em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Docentes (todos os programas)'\nfig = cria_gráfico_histograma(df_histo,título)\nfig.show()",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Docentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-docentes.html#gráficos-comparativos",
    "href": "dadosabertos-comparativo-idade-docentes.html#gráficos-comparativos",
    "title": "Idade dos Docentes dos Programas de Pós-Graduação",
    "section": "Gráficos comparativos",
    "text": "Gráficos comparativos\nPodemos fazer combinações dos gráficos mostrados acima para comparar subconjuntos do dataframe original. Para poder fazer alguns tipos de comparações é interessante verificar o percentual de docentes por faixa de idade em vez de usar números absolutos. Podemos modificar a função dataframe_para_histograma para criar também um campo com o percentual de docentes na faixa de idades:\n\ndef dataframe_para_histograma_percentual(df_filtrado):\n    ano_atual = datetime.now().year\n    # Calculamos a idade das pessoas.\n    df_filtrado['Idade'] = ano_atual - df_filtrado['AN_NASCIMENTO_DOCENTE']\n    # Usamos faixas de 5 anos dos 20 aos 75 anos, e uma faixa final para mais de 75 anos.\n    faixas = [20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 120]  \n    rotulos_faixas = [f'{i}-{i+5}' for i in range(20, 75, 5)] + ['75+']  \n    # Categorizamos as idades nas faixas.\n    df_filtrado['Faixa de Idade'] = pd.cut(df_filtrado['Idade'], bins=faixas, \n                                           labels=rotulos_faixas, right=False)\n    # Contamos o número de pessoas por faixa.\n    histo = df_filtrado['Faixa de Idade'].value_counts().reindex(rotulos_faixas, fill_value=0)\n    # Calculamos o total de pessoas para converter para percentagens.\n    total_pessoas = histo.sum()\n    # Criamos um dataframe com o histograma. Cada vaixa terá o rótulo, valores e índice.\n    df_histo = pd.DataFrame({\n        'Faixa de Idade': pd.Categorical(histo.index, categories=rotulos_faixas, ordered=True),\n        'Número': histo.values,\n        'Percentual': (histo.values / total_pessoas) * 100,  # Percentual\n        'Posição': range(len(rotulos_faixas))  # Índice\n    })\n    return df_histo, rotulos_faixas\n\nAgora que queremos comparar dois histogramas precisamos modificar a função que cria o histograma para receber um segundo histograma com os valores para comparação. O primeiro histograma (base) será plotado como visto nos exemplos anteriores, o segundo (overlay) como marcadores em cima do primeiro, facilitando a visualização.\n\ndef cria_gráfico_histograma_comparativo(df_histo_base, df_histo_overlay,título):\n    fig = px.bar(df_histo_base, x='Faixa de Idade', y='Percentual',\n                 title=título, \n                 category_orders={'Faixa de Idade': rotulos_faixas},\n                 color='Posição',  \n                 color_continuous_scale='Rainbow')\n    fig.add_trace(go.Scatter(\n        x=df_histo_overlay['Faixa de Idade'],\n        y=df_histo_overlay['Percentual'],\n        mode='markers',\n        marker=dict(\n            size=30,  \n            line=dict(width=3, color='black'), \n            color='rgba(80,80,80,0.2)',\n            opacity=1 \n        ),        \n        showlegend = False\n    ))\n    fig.update_layout(coloraxis_showscale=False)     \n    fig.update_yaxes(title_text='', \n                     tickvals=[0, 5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 80, 100], \n                     ticktext=['0%','5%','10%','15%','20%','25%','30%','35%','40%','50%','60%','80%','100%'])\n    return fig\n\nCom estas duas funções modificadas podemos explorar vários histogramas comparativos.\n\nDistribuição da idade dos docentes de um determinado programa versus todos os docentes\nVamos ver a distribuição de idade de um PPG específico comparado com todos os docentes na base de dados da CAPES. Primeiro recuperamos informações sobre o programa:\n\nnome_do_programa = df.loc[df['CD_PROGRAMA_IES'] == programa, 'NM_PROGRAMA_IES'].values[0]\nsigla_ies = df.loc[df['CD_PROGRAMA_IES'] == programa, 'SG_ENTIDADE_ENSINO'].values[0]\n\nCriamos um subconjunto de dados com os docentes do programa em questão:\n\ndf_filtrado = df[df['CD_PROGRAMA_IES'] == programa].copy()\n\nUsamos a função para calcular o histograma das idades de todos os programas e do subconjunto:\n\ndf_histo_base, rotulos_faixas = dataframe_para_histograma_percentual(df)\ndf_histo_overlay, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado)\n\nPlotamos as distribuições em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Docentes - {nome_do_programa}/{sigla_ies} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_base,df_histo_overlay,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos docentes de uma IES versus todos os docentes\nVamos refazer o exemplo anterior mas considerando todos os docentes de uma IES/ICT.\n\nsigla_ies = df.loc[df['CD_PROGRAMA_IES'] == programa, 'SG_ENTIDADE_ENSINO'].values[0]\n\nCriamos um subconjunto de dados com os docentes da IES/ICT:\n\ndf_filtrado = df[df['CD_ENTIDADE_CAPES'] == entidade].copy()\n\nUsamos a função para calcular o histograma das idades de todos os docentes da IES/ICT e do conjunto geral:\n\ndf_histo_base, rotulos_faixas = dataframe_para_histograma_percentual(df)\ndf_histo_overlay, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado)\n\nPlotamos as distribuições em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Docentes - {sigla_ies} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_base,df_histo_overlay,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos docentes de uma determinada área de avaliação versus todos os docentes\nPreparamos o título para o subconjunto:\n\nnome_da_área = df.loc[df['CD_AREA_AVALIACAO'] == área_de_avaliação, 'NM_AREA_AVALIACAO'].values[0]\ndf_filtrado = df[df['CD_AREA_AVALIACAO'] == área_de_avaliação].copy()\n\nUsamos a função para calcular o histograma das idades de todos os programas e do subconjunto da área:\n\ndf_histo_base, rotulos_faixas = dataframe_para_histograma_percentual(df)\ndf_histo_overlay, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado)\n\nPlotamos as distribuições em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Docentes na área {nome_da_área} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_base,df_histo_overlay,título)\nfig.show()",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Docentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-docentes.html#mais-gráficos-em-lote",
    "href": "dadosabertos-comparativo-idade-docentes.html#mais-gráficos-em-lote",
    "title": "Idade dos Docentes dos Programas de Pós-Graduação",
    "section": "Mais gráficos (em lote)",
    "text": "Mais gráficos (em lote)\nAs funções e trechos de código neste documento podem ser adaptadas para criar gráficos em lote.\nPrimeiro vamos verificar os códigos de programas de pós-graduação associados a uma IES/ICT (dado seu código):\n\nlista_entidades = df[df['CD_ENTIDADE_CAPES'] == entidade]\nppgs_da_entidade = lista_entidades['CD_PROGRAMA_IES'].unique()\nlista_ppgs_da_entidade = ppgs_da_entidade.tolist()\nlista_ppgs_da_entidade\n\n['33010013005P0',\n '33010013008P0',\n '33010013002P1',\n '33010013011P0',\n '33010013009P6',\n '33010013003P8',\n '33010013010P4']\n\n\nCom esta lista posso criar um gráfico para cada programa, comparando as idades dos docentes daquele programa com os de suas áreas de avaliação:\n\nfor programa in lista_ppgs_da_entidade:\n    df_programa = df[df['CD_PROGRAMA_IES'] == programa].copy()\n    nm_programa = df_programa['NM_PROGRAMA_IES'].iloc[0]\n    cd_area_avaliacao = df_programa['CD_AREA_AVALIACAO'].iloc[0]\n    nm_area_avaliacao = df_programa['NM_AREA_AVALIACAO'].iloc[0]\n    df_area = df[df['CD_AREA_AVALIACAO'] == cd_area_avaliacao].copy()\n    df_histo_program, rotulos_faixas = dataframe_para_histograma_percentual(df_programa)\n    df_histo_area, _ = dataframe_para_histograma_percentual(df_area)\n    title = f'Percentual de Idade de Docentes: {nm_programa} x área {nm_area_avaliacao}'\n    fig = cria_gráfico_histograma_comparativo(df_histo_area, df_histo_program, title)\n    fig.update_layout(margin=dict(t=50, b=100)) \n    fig.show()",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Docentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-discentes.html",
    "href": "dadosabertos-comparativo-idade-discentes.html",
    "title": "Idade dos Discentes dos Programas de Pós-Graduação",
    "section": "",
    "text": "Este documento apresenta código e procedimentos para criar gráficos e análises comparativas sobre a idade dos discentes dos programas de pós-graduação.",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Discentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-discentes.html#sobre",
    "href": "dadosabertos-comparativo-idade-discentes.html#sobre",
    "title": "Idade dos Discentes dos Programas de Pós-Graduação",
    "section": "",
    "text": "Este documento apresenta código e procedimentos para criar gráficos e análises comparativas sobre a idade dos discentes dos programas de pós-graduação.",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Discentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-discentes.html#obtendo-os-dados",
    "href": "dadosabertos-comparativo-idade-discentes.html#obtendo-os-dados",
    "title": "Idade dos Discentes dos Programas de Pós-Graduação",
    "section": "Obtendo os dados",
    "text": "Obtendo os dados\nPrimeiro verifique na seção Dados sobre Discentes da Pós-Graduação Stricto Sensu no Brasil como baixar as planilhas com dados de docentes. Para os exemplos neste documento usaremos o arquivo br-capes-colsucup-discentes-2022-2023-11-30.xlsx (versão mais atual quando o documento foi criado).\n\n\n\n\n\n\nAtenção\n\n\n\nOs dados usados neste documento são de 2022.",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Discentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-discentes.html#lendo-e-filtrando-os-dados",
    "href": "dadosabertos-comparativo-idade-discentes.html#lendo-e-filtrando-os-dados",
    "title": "Idade dos Discentes dos Programas de Pós-Graduação",
    "section": "Lendo e filtrando os dados",
    "text": "Lendo e filtrando os dados\nVamos obter um dataframe com os dados da planilha br-capes-colsucup-discentes-2022-2023-11-30.xlsx, mantendo somente as colunas relevantes para os gráficos neste documento. Primeiro importamos as bibliotecas necessárias:\n\nimport pandas as pd\nimport re\nimport warnings\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime\n\nPara facilitar a modificação do código para gerar gráficos comparando programas, regiões, áreas de avaliação e entidades de ensino vamos definir algumas constantes para filtrar os dados depois de lidos.\n\narquivo = 'Resources/Data/DadosAbertos/br-capes-colsucup-discentes-2022-2023-11-30.xlsx'\nprograma = '33010013002P1' # COMPUTAÇÃO APLICADA\nentidade = 33010013 # INSTITUTO NACIONAL DE PESQUISAS ESPACIAIS\nuf = 'SP'\nregião = 'SUDESTE'\nárea_de_avaliação = 45 # Interdisciplinar\n\nAgora podemos ler a planilha, selecionar e ajustar colunas se necessário:\n\n# Lemos a planilha ignorando avisos.\nwith warnings.catch_warnings():\n    warnings.filterwarnings(\"ignore\", category=UserWarning, \n                            module=re.escape('openpyxl.styles.stylesheet'))\n    df = pd.read_excel(arquivo,engine='openpyxl')\n    # Removemos os campos indesejados (especialmente as identificações dos docentes).    \n    keep = ['CD_AREA_AVALIACAO', 'NM_AREA_AVALIACAO', 'CD_PROGRAMA_IES', 'NM_PROGRAMA_IES',\n            'CD_CONCEITO_PROGRAMA', 'CD_ENTIDADE_CAPES', \n            'SG_ENTIDADE_ENSINO', 'NM_ENTIDADE_ENSINO', \n            'SG_UF_PROGRAMA', 'NM_REGIAO', \n            'ID_PESSOA', 'AN_NASCIMENTO_DISCENTE', 'DS_GRAU_ACADEMICO_DISCENTE',\n            'NM_SITUACAO_DISCENTE', 'QT_MES_TITULACAO', \n             ]\n    df = df[keep]",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Discentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-discentes.html#gráficos",
    "href": "dadosabertos-comparativo-idade-discentes.html#gráficos",
    "title": "Idade dos Discentes dos Programas de Pós-Graduação",
    "section": "Gráficos",
    "text": "Gráficos\nCom os dados lidos e preprocessados podemos aplicar filtros e criar os gráficos. Os passos envolvem selecionar parte do dataframe, criar um histograma e exibir este histograma em um gráfico.\nO dataframe original contém uma coluna, DS_FAIXA_ETARIA, que já representa a faixa etária dos discentes, mas criaremos um novo histograma a partir do ano de nascimento para ficar mais atual e flexível.\nO passo de criação do histograma pode ser feito através de uma função que já pode ser definida como:\n\ndef dataframe_para_histograma(df):\n    ano_atual = datetime.now().year\n    # Calculamos a idade das pessoas.\n    df['Idade'] = ano_atual - df['AN_NASCIMENTO_DISCENTE']    \n    # Usamos faixas de 5 anos dos 15 aos 75 anos, e uma faixa final para mais de 75 anos.\n    faixas = [15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 120]  \n    rotulos_faixas = [f'{i}-{i+5}' for i in range(15, 75, 5)] + ['75+']  \n    # Categorizamos as idades nas faixas.\n    df['Faixa de Idade'] = pd.cut(df['Idade'], bins=faixas, \n                                  labels=rotulos_faixas, right=False)\n    # Contamos o número de pessoas por faixa.\n    histo = df['Faixa de Idade'].value_counts().reindex(rotulos_faixas, fill_value=0)\n    # Criamos um dataframe com o histograma. Cada vaixa terá o rótulo, valores e índice.\n    df_histo = pd.DataFrame({\n        'Faixa de Idade': pd.Categorical(histo.index, categories=rotulos_faixas, ordered=True),\n        'Número': histo.values,\n        'Posição': range(len(rotulos_faixas)) \n    })\n    return df_histo, rotulos_faixas\n\nTambém podemos definir uma função que cria um gráfico com o histograma, assim garantimos uma consistência visual em gráficos semelhantes:\n\ndef cria_gráfico_histograma(df_histo,título):\n    fig = px.bar(df_histo, x='Faixa de Idade', y='Número',\n                 title=título, \n                 category_orders={'Faixa de Idade': rotulos_faixas},\n                 color='Posição',  \n                 color_continuous_scale='Rainbow')\n    fig.update_layout(coloraxis_showscale=False)     \n    fig.update_yaxes(title_text='')      \n    return fig\n\n\nDistribuição da idade dos discentes do programa\nVamos ver a distribuição de idades dos discentes de um programa. Primeiro filtramos o dataframe:\n\nnome_do_programa = df.loc[df['CD_PROGRAMA_IES'] == programa, 'NM_PROGRAMA_IES'].values[0]\nsigla_ies = df.loc[df['CD_PROGRAMA_IES'] == programa, 'SG_ENTIDADE_ENSINO'].values[0]\ndf_programa = df[df['CD_PROGRAMA_IES'] == programa].copy()\n\nUsamos a função para calcular o histograma das idades:\n\ndf_histo, rotulos_faixas = dataframe_para_histograma(df_programa)\n\nE plotamos a distribuição em um gráfico interativo:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Discentes para {nome_do_programa} - {sigla_ies}'\nfig = cria_gráfico_histograma(df_histo,título)\nfig.show()\n\n                                                \n\n\nDevemos lembrar que os dados usados para criar este gráfico contém informações de alunos de mestrado e doutorado, e é de se esperar uma diferença de idade entre alunos nestes níveis. Faz mais sentido então criar os gráficos separados para mestrado e doutorado, filtrando novamente os dados:\n\ndf_filtrado_mestrado = df_programa[df_programa['DS_GRAU_ACADEMICO_DISCENTE'] == 'MESTRADO'].copy()\ndf_filtrado_doutorado = df_programa[df_programa['DS_GRAU_ACADEMICO_DISCENTE'] == 'DOUTORADO'].copy()\n\n\n\n\n\n\n\nAtenção\n\n\n\nO campo DS_GRAU_ACADEMICO_DISCENTE pode receber os valores MESTRADO, DOUTORADO, MESTRADO PROFISSIONAL e DOUTORADO PROFISSIONAL. Ajuste os filtros dependendo dos graus que seu programa pode conferir aos alunos.\n\n\nCalculamos então os histogramas para cada um dos níveis:\n\ndf_histomestrado, rotulos_faixas = dataframe_para_histograma(df_filtrado_mestrado)\ndf_histodoutorado, rotulos_faixas = dataframe_para_histograma(df_filtrado_doutorado)\n\nE criamos os gráficos separadamente para cada nível:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Mestrandos para {nome_do_programa} - {sigla_ies}'\nfig = cria_gráfico_histograma(df_histomestrado,título)\nfig.show()\n\n                                                \n\n\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Doutorandos para {nome_do_programa} - {sigla_ies}'\nfig = cria_gráfico_histograma(df_histodoutorado,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos discentes da IES\nUsando este primeiro exemplo podemos facilmente criar gráficos sobre outros filtros do dataframe original. Este é sobre a idade dos discentes da institução.\n\nnome_da_entidade = df.loc[df['CD_ENTIDADE_CAPES'] == entidade, 'NM_ENTIDADE_ENSINO'].values[0]\n\ndf_filtrado = df[df['CD_ENTIDADE_CAPES'] == entidade].copy()\ndf_filtrado_mestrado = df_filtrado[df_filtrado['DS_GRAU_ACADEMICO_DISCENTE'] == 'MESTRADO'].copy()\ndf_filtrado_doutorado = df_filtrado[df_filtrado['DS_GRAU_ACADEMICO_DISCENTE'] == 'DOUTORADO'].copy()\n\nUsamos a função para calcular os histogramas das idades por nível:\n\ndf_histomestrado, rotulos_faixas = dataframe_para_histograma(df_filtrado_mestrado)\ndf_histodoutorado, rotulos_faixas = dataframe_para_histograma(df_filtrado_doutorado)\n\nE plotamos a distribuição em dois gráficos interativos:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Mestrandos para {nome_da_entidade}'\nfig = cria_gráfico_histograma(df_histomestrado,título)\nfig.show()\n\n                                                \n\n\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Doutorandos para {nome_da_entidade}'\nfig = cria_gráfico_histograma(df_histodoutorado,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos discentes de uma determinada área de avaliação\nVejamos agora como filtrar os discentes de programas vinculados a uma área de avaliação:\n\nnome_da_área = df.loc[df['CD_AREA_AVALIACAO'] == área_de_avaliação, 'NM_AREA_AVALIACAO'].values[0]\ndf_filtrado = df[df['CD_AREA_AVALIACAO'] == área_de_avaliação].copy()\ndf_filtrado_mestrado = df_filtrado[df_filtrado['DS_GRAU_ACADEMICO_DISCENTE'] == 'MESTRADO'].copy()\ndf_filtrado_doutorado = df_filtrado[df_filtrado['DS_GRAU_ACADEMICO_DISCENTE'] == 'DOUTORADO'].copy()\n\nUsamos a função para calcular os histogramas das idades:\n\ndf_histomestrado, rotulos_faixas = dataframe_para_histograma(df_filtrado_mestrado)\ndf_histodoutorado, rotulos_faixas = dataframe_para_histograma(df_filtrado_doutorado)\n\nE plotamos a distribuição em dois gráficos interativos:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Mestrandos na área {nome_da_área}'\nfig = cria_gráfico_histograma(df_histomestrado,título)\nfig.show()\n\n                                                \n\n\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição de Idade de Doutorandos na área {nome_da_área}'\nfig = cria_gráfico_histograma(df_histodoutorado,título)\nfig.show()",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Discentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-discentes.html#gráficos-comparativos",
    "href": "dadosabertos-comparativo-idade-discentes.html#gráficos-comparativos",
    "title": "Idade dos Discentes dos Programas de Pós-Graduação",
    "section": "Gráficos comparativos",
    "text": "Gráficos comparativos\nPodemos fazer combinações dos gráficos mostrados acima para comparar subconjuntos do dataframe original. Para poder fazer alguns tipos de comparações é interessante verificar o percentual de discentes por faixa de idade em vez de usar números absolutos. Podemos modificar a função dataframe_para_histograma para criar também um campo com o percentual de discentes na faixa de idades:\n\ndef dataframe_para_histograma_percentual(df_filtrado):\n    ano_atual = datetime.now().year\n    # Calculamos a idade das pessoas.\n    df_filtrado['Idade'] = ano_atual - df_filtrado['AN_NASCIMENTO_DISCENTE']\n    # Usamos faixas de 5 anos dos 20 aos 75 anos, e uma faixa final para mais de 75 anos.\n    faixas = [15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 120]  \n    rotulos_faixas = [f'{i}-{i+5}' for i in range(15, 75, 5)] + ['75+']  \n    # Categorizamos as idades nas faixas.\n    df_filtrado['Faixa de Idade'] = pd.cut(df_filtrado['Idade'], bins=faixas, \n                                           labels=rotulos_faixas, right=False)\n    # Contamos o número de pessoas por faixa.\n    histo = df_filtrado['Faixa de Idade'].value_counts().reindex(rotulos_faixas, fill_value=0)\n    # Calculamos o total de pessoas para converter para percentagens.\n    total_pessoas = histo.sum()\n    # Criamos um dataframe com o histograma. Cada faixa terá o rótulo, valores e índice.\n    df_histo = pd.DataFrame({\n        'Faixa de Idade': pd.Categorical(histo.index, categories=rotulos_faixas, ordered=True),\n        'Número': histo.values,\n        'Percentual': (histo.values / total_pessoas) * 100,  # Percentual\n        'Posição': range(len(rotulos_faixas))  # Índice\n    })\n    return df_histo, rotulos_faixas\n\nAgora que queremos comparar dois histogramas precisamos modificar a função que cria o histograma para receber um segundo histograma com os valores para comparação. O primeiro histograma (base) será plotado como visto nos exemplos anteriores, o segundo (overlay) como marcadores em cima do primeiro, facilitando a visualização.\n\ndef cria_gráfico_histograma_comparativo(df_histo_base, df_histo_overlay,título):\n    fig = px.bar(df_histo_base, x='Faixa de Idade', y='Percentual',\n                 title=título, \n                 category_orders={'Faixa de Idade': rotulos_faixas},\n                 color='Posição',  \n                 color_continuous_scale='Rainbow')\n    fig.add_trace(go.Scatter(\n        x=df_histo_overlay['Faixa de Idade'],\n        y=df_histo_overlay['Percentual'],\n        mode='markers',\n        marker=dict(\n            size=30,  \n            line=dict(width=3, color='black'), \n            color='rgba(80,80,80,0.2)',\n            opacity=1 \n        ),        \n        showlegend = False\n    ))\n    fig.update_layout(coloraxis_showscale=False)     \n    fig.update_yaxes(title_text='', \n                     tickvals=[0, 5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 80, 100], \n                     ticktext=['0%','5%','10%','15%','20%','25%','30%','35%','40%','50%','60%','80%','100%'])\n    return fig\n\nCom estas duas funções modificadas podemos explorar vários histogramas comparativos.\n\nDistribuição da idade dos discentes de um determinado programa versus todos os discentes\nVamos ver a distribuição de idade de um PPG específico comparado com todos os discentes na base de dados da CAPES (por nível). Primeiro recuperamos informações sobre o programa:\n\nnome_do_programa = df.loc[df['CD_PROGRAMA_IES'] == programa, 'NM_PROGRAMA_IES'].values[0]\nsigla_ies = df.loc[df['CD_PROGRAMA_IES'] == programa, 'SG_ENTIDADE_ENSINO'].values[0]\n\nCriamos dois subconjuntos de dados com os discentes do programa em questão (um para mestrado e outro para doutorado):\n\ndf_filtrado_mestrado_todos = df[df['DS_GRAU_ACADEMICO_DISCENTE'] == 'MESTRADO'].copy()\ndf_filtrado_doutorado_todos = df[df['DS_GRAU_ACADEMICO_DISCENTE'] == 'DOUTORADO'].copy()\ndf_filtrado_mestrado_ppg = df[(df['CD_PROGRAMA_IES'] == programa) & \n                              (df['DS_GRAU_ACADEMICO_DISCENTE'] == 'MESTRADO')].copy()\ndf_filtrado_doutorado_ppg = df[(df['CD_PROGRAMA_IES'] == programa) & \n                               (df['DS_GRAU_ACADEMICO_DISCENTE'] == 'DOUTORADO')].copy()\n\nUsamos a função para calcular os histogramas das idades de todos os programas e do subconjunto (por níveis):\n\ndf_histo_mestrado_todos, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_mestrado_todos)\ndf_histo_doutorado_todos, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_doutorado_todos)\ndf_histo_mestrado_ppg, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_mestrado_ppg)\ndf_histo_doutorado_ppg, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_doutorado_ppg)\n\nPlotamos as distribuições em dois gráficos interativos:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Mestrandos - {nome_do_programa}/{sigla_ies} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_mestrado_todos,df_histo_mestrado_ppg,título)\nfig.show()\n\n                                                \n\n\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Doutorandos - {nome_do_programa}/{sigla_ies} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_doutorado_todos,df_histo_doutorado_ppg,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos discentes de uma IES versus todos os discentes\nVamos refazer o exemplo anterior mas considerando todos os discentes de uma IES/ICT. Primeiro achamos o nome da IES/ICT:\n\nsigla_ies = df.loc[df['CD_PROGRAMA_IES'] == programa, 'SG_ENTIDADE_ENSINO'].values[0]\n\nCriamos um subconjunto de dados com os discentes da IES/ICT:\n\ndf_filtrado_mestrado_ies = df[(df['CD_ENTIDADE_CAPES'] == entidade) & \n                              (df['DS_GRAU_ACADEMICO_DISCENTE'] == 'MESTRADO')].copy()\ndf_filtrado_doutorado_ies = df[(df['CD_ENTIDADE_CAPES'] == entidade) & \n                               (df['DS_GRAU_ACADEMICO_DISCENTE'] == 'DOUTORADO')].copy()\n\nUsamos a função para calcular o histograma das idades de todos os discentes da IES/ICT e do conjunto geral:\n\ndf_histo_mestrado_ies, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_mestrado_ies)\ndf_histo_doutorado_ies, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_doutorado_ies)\n\nPlotamos as distribuições em dois gráficos interativos:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Mestrandos - {sigla_ies} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_mestrado_todos,df_histo_mestrado_ies,título)\nfig.show()\n\n                                                \n\n\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Doutorandos - {sigla_ies} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_doutorado_todos,df_histo_doutorado_ies,título)\nfig.show()\n\n                                                \n\n\n\n\nDistribuição da idade dos discentes de uma determinada área de avaliação versus todos os discentes\nPreparamos o título para o subconjunto:\n\nnome_da_área = df.loc[df['CD_AREA_AVALIACAO'] == área_de_avaliação, 'NM_AREA_AVALIACAO'].values[0]\n\nCriamos um subconjunto de dados com os discentes de PPGs da área:\n\ndf_filtrado_mestrado_area = df[(df['CD_AREA_AVALIACAO'] == área_de_avaliação) & \n                               (df['DS_GRAU_ACADEMICO_DISCENTE'] == 'MESTRADO')].copy()\ndf_filtrado_doutorado_area = df[(df['CD_AREA_AVALIACAO'] == área_de_avaliação) & \n                                (df['DS_GRAU_ACADEMICO_DISCENTE'] == 'DOUTORADO')].copy()\n\nUsamos a função para calcular o histograma das idades de todos os discentes de PPGs da área e do conjunto geral:\n\ndf_histo_mestrado_area, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_mestrado_area)\ndf_histo_doutorado_area, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_doutorado_area)\n\nPlotamos as distribuições em dois gráficos interativos:\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Mestrandos - {nome_da_área} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_mestrado_todos,df_histo_mestrado_area,título)\nfig.show()\n\n                                                \n\n\n\n# Crio e mostro o gráfico de barras.\ntítulo = f'Distribuição Percentual de Idade de Doutorandos - {nome_da_área} x todos os PPGs'\nfig = cria_gráfico_histograma_comparativo(df_histo_doutorado_todos,df_histo_doutorado_area,título)\nfig.show()",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Discentes"
    ]
  },
  {
    "objectID": "dadosabertos-comparativo-idade-discentes.html#mais-gráficos-em-lote",
    "href": "dadosabertos-comparativo-idade-discentes.html#mais-gráficos-em-lote",
    "title": "Idade dos Discentes dos Programas de Pós-Graduação",
    "section": "Mais gráficos (em lote)",
    "text": "Mais gráficos (em lote)\nAs funções e trechos de código neste documento podem ser adaptadas para criar gráficos em lote.\nPrimeiro vamos verificar os códigos de programas de pós-graduação associados a uma IES/ICT (dado seu código):\n\nlista_entidades = df[df['CD_ENTIDADE_CAPES'] == entidade]\nppgs_da_entidade = lista_entidades['CD_PROGRAMA_IES'].unique()\nlista_ppgs_da_entidade = ppgs_da_entidade.tolist()\n\nCom esta lista posso criar um gráfico para cada programa, comparando as idades dos discentes daquele programa com os de suas áreas de avaliação:\n\nfor programa in lista_ppgs_da_entidade:\n    # Crio um subconjunto para o programa ignorando se tem mestrado e/ou doutorado.\n    # Será usado para recuperar informações sobre o programa e área.\n    df_filtrado_ppg = df[(df['CD_PROGRAMA_IES'] == programa)].copy()\n    # Recuperamos o nome do programa e de sua área de avaliação:\n    nm_programa = df_filtrado_ppg['NM_PROGRAMA_IES'].iloc[0]\n    cd_area_avaliacao = df_filtrado_ppg['CD_AREA_AVALIACAO'].iloc[0]\n    nm_area_avaliacao = df_filtrado_ppg['NM_AREA_AVALIACAO'].iloc[0]\n    # Recuperamos os níveis oferecidos:\n    níveis = df_filtrado_ppg['DS_GRAU_ACADEMICO_DISCENTE'].unique().tolist()\n    for nível in níveis:\n        # Crio um subconjunto e histograma para o nível considerando todos os programas da área:\n        df_filtrado_nível_área = df[(df['CD_AREA_AVALIACAO'] == cd_area_avaliacao) & \n                                   (df['DS_GRAU_ACADEMICO_DISCENTE'] == nível)].copy()\n        df_histo_nível_área, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_nível_área)\n        # Crio um subconjunto e histograma para o nível considerando somente este programa:\n        df_filtrado_nível_ppg = df[(df['CD_PROGRAMA_IES'] == programa) & \n                                   (df['DS_GRAU_ACADEMICO_DISCENTE'] == nível)].copy()\n        df_histo_nível_ppg, rotulos_faixas = dataframe_para_histograma_percentual(df_filtrado_nível_ppg)\n        # Crio o gráfico comparativo.\n        título = f'Idade de Discentes {nível} em {nm_programa} x {nm_area_avaliacao}'\n        fig = cria_gráfico_histograma_comparativo(df_histo_nível_área, df_histo_nível_ppg, título)\n        fig.update_layout(margin=dict(t=50, b=100)) \n        fig.show()",
    "crumbs": [
      "Dados Abertos",
      "Idades dos Discentes"
    ]
  },
  {
    "objectID": "sucupira-producao-eda.html",
    "href": "sucupira-producao-eda.html",
    "title": "Análise de Básica de Dados da Plataforma Sucupira",
    "section": "",
    "text": "Na seção Baixando os dados obtivemos vários dados da Plataforma Sucupira, e na seção Pré-Processamento dos Dados reorganizamos os dados baixados em dataframes.\nNeste documento veremos como criar alguns gráficos sobre a produção intelectual do nosso programa. Os códigos neste documento assumem que os dataframes foram pré-processados e armazenados como mostrado na seção Pré-Processamento dos Dados."
  },
  {
    "objectID": "sucupira-producao-eda.html#sobre",
    "href": "sucupira-producao-eda.html#sobre",
    "title": "Análise de Básica de Dados da Plataforma Sucupira",
    "section": "",
    "text": "Na seção Baixando os dados obtivemos vários dados da Plataforma Sucupira, e na seção Pré-Processamento dos Dados reorganizamos os dados baixados em dataframes.\nNeste documento veremos como criar alguns gráficos sobre a produção intelectual do nosso programa. Os códigos neste documento assumem que os dataframes foram pré-processados e armazenados como mostrado na seção Pré-Processamento dos Dados."
  },
  {
    "objectID": "sucupira-producao-eda.html#análise-exploratória-de-dados",
    "href": "sucupira-producao-eda.html#análise-exploratória-de-dados",
    "title": "Análise de Básica de Dados da Plataforma Sucupira",
    "section": "Análise Exploratória de Dados",
    "text": "Análise Exploratória de Dados\nAntes de mostrar os gráficos e códigos que os criaram vamos importar as bibliotecas necessárias. Usaremos a biblioteca Plotly para os gráficos:\n\nimport pandas as pd\nimport plotly.graph_objs as go\nimport plotly.express as px\n\n\nQual é o perfil de nossa produção tecnológica?\nPodemos ver a quantidade e proporção dos diferentes tipos de produção tecnológica com um gráfico do tipo sunburst. Primeiro lemos o dataframe com toda a produção unificada:\n\ndir = \"Resources/Data/ColetaSucupira/\"\ndf = pd.read_csv(dir+\"CategoriaDeAutoresPorProdução-Unificada.csv\")\n\nPara criar um gráfico do tipo sunburst é preciso agrupar os dados do dataframe pelos níveis hierárquicos desejados, calculando a quantidade de itens que pertence a cada combinação dos níveis. O código a seguir faz isto:\n\ndfAgrupado = df.groupby(['Tipo da Produção', 'Subtipo da Produção']).\\\n                         size().reset_index(name='Total')\n# Criamos a figura.\nfig = px.sunburst(dfAgrupado, path=['Tipo da Produção', 'Subtipo da Produção'], \n                  values='Total')\nfig.update_traces(hovertemplate='&lt;b&gt;Tipo:&lt;/b&gt; %{label}&lt;br&gt;'+\n                                '&lt;b&gt;Subtipo:&lt;/b&gt; %{parent}&lt;br&gt;'+\n                                '&lt;b&gt;Total:&lt;/b&gt; %{value}')\nfig.show()\n\n                                                \n\n\n\n\nQual é a evolução da nossa produção tecnológica?\nPodemos ver o total por ano das produções tecnológicas de nosso programa com um gráfico de barras. Primeiro é preciso agrupar as produções por ano:\n\ndfProdPorAno = df.groupby('Ano da Produção').size()\n\nCom as produções agrupadas podemos criar um gráfico de barras com o código abaixo:\n\nfig = go.Figure()\nfig.add_trace(go.Bar(\n              x=dfProdPorAno.index,y=dfProdPorAno.values,\n              text=dfProdPorAno.values,\n              marker_color='#1269B1'))\nfig.update_layout(title='Produções Intelectuais por Ano',\n                  xaxis=dict(title='Ano', tickmode='linear', tick0=0, dtick=1),\n                  yaxis=dict(title='Produções'))    \nfig.show()    \n\n                                                \n\n\nPodemos detalhar o gráfico usando cores diferentes para cada tipo e subtipo da produção. Como temos 14 ou mais combinações de tipos e subtipos será melhor fazer dois gráficos separados, um para Tipo da Produção = BIBLIOGRÁFICA e outro para Tipo da Produção = TÉCNICA.\nVamos começar com as produções bibliográficas, criando um subconjunto do dataframe completo e agrupando por ano e subtipo:\n\ndfProdBibliográfica = df[df['Tipo da Produção'] == 'BIBLIOGRÁFICA']\ndfProdPorAnoECat = dfProdBibliográfica.groupby(['Ano da Produção', \n                                                'Subtipo da Produção']).\\\n                                                 size().reset_index(name='Produções')\n\nA criação do gráfico de barras empilhadas é feita com este código:\n\nfig = px.bar(dfProdPorAnoECat, \n             x='Ano da Produção',y='Produções', \n             color='Subtipo da Produção', \n             barmode='stack')\nfig.update_layout(title='Produções Bibliográficas por Ano',\n                  xaxis=dict(title='Ano', tickmode='linear', tick0=0, dtick=1),\n                  yaxis=dict(title='Produções'))    \nfig.show()\n\n                                                \n\n\nAgora faremos o mesmo para produções técnicas:\n\ndfProdTécnica = df[df['Tipo da Produção'] == 'TÉCNICA']\ndfProdPorAnoECat = dfProdTécnica.groupby(['Ano da Produção', \n                                          'Subtipo da Produção']).\\\n                                          size().reset_index(name='Produções')\n\nUsamos basicamente o mesmo código para criar o gráfico de barras empilhadas:\n\nfig = px.bar(dfProdPorAnoECat, \n             x='Ano da Produção',y='Produções', \n             color='Subtipo da Produção', \n             barmode='stack')\nfig.update_layout(title='Produções Técnicas por Ano',\n                  xaxis=dict(title='Ano', tickmode='linear', tick0=0, dtick=1),\n                  yaxis=dict(title='Produções'))    \nfig.show()\n\n                                                \n\n\n\n\nQual é a evolução da nossa produção tecnológica (com coautoria discente)?\nVamos ver quanto da nossa produção tecnológica tem coautoria discente por ano. Para isto preciso separar o dataframe em dois complementares, e agrupar estes dois pelo ano da produção:\n\ndfProdComDisc = df[df['Discente'] &gt; 0]\ndfProdComDisc = dfProdComDisc.groupby('Ano da Produção').size()\ndfProdSemDisc = df[df['Discente'] == 0]\ndfProdSemDisc = dfProdSemDisc.groupby('Ano da Produção').size()\n\nVamos usar dois traços no gráfico:\n\ntraçoComDiscentes = go.Bar(x=dfProdComDisc.index,y=dfProdComDisc.values,\n                           name='Com Discentes',marker_color='#0dbf7b')\ntraçoSemDiscentes = go.Bar(x=dfProdSemDisc.index,y=dfProdSemDisc.values,\n                           name='Sem Discentes',marker_color='#220dbf')\n\nCriamos e ajustamos a figura:\n\nfig = go.Figure(data=[traçoComDiscentes, traçoSemDiscentes])\nfig.update_layout(\n    title='Produções Intelectuais por Ano (com participação de discentes)',\n    xaxis=dict(title='Ano', tickmode='linear', tick0=0, dtick=1),\n    yaxis=dict(title='Produções'),\n    barmode='stack')\nfig.show()\n\n                                                \n\n\nMas queremos visualizar também as produções bibliográficas com coautoria por ano. Vamos refazer o dataframe com este filtro adicional:\n\ndfProdComDisc = dfProdBibliográfica[dfProdBibliográfica['Discente'] &gt; 0]\ndfProdComDisc = dfProdComDisc.groupby('Ano da Produção').size()\ndfProdSemDisc = dfProdBibliográfica[dfProdBibliográfica['Discente'] == 0]\ndfProdSemDisc = dfProdSemDisc.groupby('Ano da Produção').size()\n\nRecriamos os traços:\n\ntraçoComDiscentes = go.Bar(x=dfProdComDisc.index,y=dfProdComDisc.values,\n                           name='Com Discentes',marker_color='#0dbf7b')\ntraçoSemDiscentes = go.Bar(x=dfProdSemDisc.index,y=dfProdSemDisc.values,\n                           name='Sem Discentes',marker_color='#220dbf')\n\nE o gráfico, com basicamente os mesmos comandos de antes.\n\nfig = go.Figure(data=[traçoComDiscentes, traçoSemDiscentes])\nfig.update_layout(\n    title='Produções Bibliográficas por Ano (com participação de discentes)',\n    xaxis=dict(title='Ano', tickmode='linear', tick0=0, dtick=1),\n    yaxis=dict(title='Produções'),\n    barmode='stack')\nfig.show()\n\n                                                \n\n\n\n\nQual é a evolução da nossa produção tecnológica (com único autor)?\nUm dos indicadores da interdisciplinaridade é a quantidade de publicações em coautorias. Para verificar o histórico destas publicações vamos criar um novo campo para o dataframe original que contém a quantidade de autores independente da categoria:\n\ndf['NumAutores'] = df[['Docente', 'Egresso', 'Participante Externo', \\\n                       'Pós-Doc', 'Sem Categoria', 'Discente']].sum(axis=1)\n\nVamos considerar somente produções do tipo BIBLIOGRÁFICA:\n\ndfProdBibliográfica = df[df['Tipo da Produção'] == 'BIBLIOGRÁFICA']\n\nCom isto podemos criar os dataframes filtrados:\n\ndfProdCom1 = dfProdBibliográfica[dfProdBibliográfica['NumAutores'] == 1]\ndfProdCom1 = dfProdCom1.groupby('Ano da Produção').size()\ndfProdComN = dfProdBibliográfica[dfProdBibliográfica['NumAutores'] &gt; 1]\ndfProdComN = dfProdComN.groupby('Ano da Produção').size()\n\nE agora os traços:\n\ntraçoCom1 = go.Bar(x=dfProdCom1.index,y=dfProdCom1.values,\n                   name='Um Autor',marker_color='#0dbf7b')\ntraçoComN = go.Bar(x=dfProdComN.index,y=dfProdComN.values,\n                   name='Vários Autores',marker_color='#220dbf')\n\n\nfig = go.Figure(data=[traçoCom1, traçoComN])\nfig.update_layout(\n    title='Produções Bibliográficas por Ano (com coautorias)',\n    xaxis=dict(title='Ano', tickmode='linear', tick0=0, dtick=1),\n    yaxis=dict(title='Produções'),\n    barmode='stack')\nfig.show()"
  },
  {
    "objectID": "dadosabertos-coautorias.html",
    "href": "dadosabertos-coautorias.html",
    "title": "Análise de Coautorias",
    "section": "",
    "text": "Este documento apresenta código e procedimentos para criar gráficos e análises sobre coautoria de trabalhos de discentes e docentes dos programas de pós-graduação.",
    "crumbs": [
      "Dados Abertos",
      "Coautorias"
    ]
  },
  {
    "objectID": "dadosabertos-coautorias.html#sobre",
    "href": "dadosabertos-coautorias.html#sobre",
    "title": "Análise de Coautorias",
    "section": "",
    "text": "Este documento apresenta código e procedimentos para criar gráficos e análises sobre coautoria de trabalhos de discentes e docentes dos programas de pós-graduação.",
    "crumbs": [
      "Dados Abertos",
      "Coautorias"
    ]
  },
  {
    "objectID": "dadosabertos-coautorias.html#obtendo-os-dados",
    "href": "dadosabertos-coautorias.html#obtendo-os-dados",
    "title": "Análise de Coautorias",
    "section": "Obtendo os dados",
    "text": "Obtendo os dados\nPrimeiro verifique na seção Dados sobre Discentes da Pós-Graduação Stricto Sensu no Brasil como baixar as planilhas com dados de docentes. Para os exemplos neste documento usaremos os arquivos br-capes-col-prod-2004a2012-2018-08-01-bibliografica-artpe.xlsx, br-capes-colsucup-producao-2013a2016-2020-06-30-bibliografica-artpe.xlsx, br-capes-colsucup-producao-2017a2020-2023-11-30-bibliografica-artpe_parte1.xlsx, br-capes-colsucup-producao-2017a2020-2023-11-30-bibliografica-artpe_parte2.xlsx, br-capes-colsucup-producao-2021a2024-2023-10-31-bibliografica-artpe.xlsx (versões mais atuais quando o documento foi criado). Veja também a Tabela Arquivos com dados sobre Artigos em Periódicos.\n\n\n\n\n\n\nAtenção\n\n\n\nOs dados usados neste documento são de 2022.",
    "crumbs": [
      "Dados Abertos",
      "Coautorias"
    ]
  },
  {
    "objectID": "dadosabertos-coautorias.html#lendo-e-filtrando-os-dados",
    "href": "dadosabertos-coautorias.html#lendo-e-filtrando-os-dados",
    "title": "Análise de Coautorias",
    "section": "Lendo e filtrando os dados",
    "text": "Lendo e filtrando os dados\n\nimport pandas as pd\nimport glob\nimport re\nimport warnings\nfrom IPython.display import Markdown\n\nPara cada planilha vamos ler a aba Produção Intelectual da planilha, filtrar alguns campos que não são necessários e separar somente as linhas que tem nomes de autores. Como repetiremos estes passos para cada planilha é melhor definir uma função em Python que recebe o nome do arquivo e retorna um dataframe com os campos e linhas que precisamos:\n\ndef preprocessaProducoes(fileName):\n    # Lemos a planilha.\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\"ignore\", category=UserWarning, \n                                module=re.escape('openpyxl.styles.stylesheet'))\n        df = pd.read_excel(fileName,engine='openpyxl',sheet_name='Produção Intelectual')\n    # Removemos os campos indesejados.    \n    keep = ['Ano da Produção', 'Título da Produção', 'Produção Glosada?',\n            'Tipo da Produção', 'Subtipo da Produção', \n            'Nome do Detalhamento', 'Valor do Detalhamento',\n            'Nome do Autor', 'Categoria do Autor'\n             ]\n    df = df[keep]\n    return df\n\nA biblioteca usada para a leitura de planilhas gera advertências no código, para isto usamos filtros de alertas (veja mais detalhes aqui).\nOs dados que precisamos estão todos armazenados em planilhas, uma por ano, em um diretório (a lista de planilhas para este documento pode ser vista aqui):\n\ndir = \"Resources/Data/ColetaSucupira/\"\n\nPodemos então criar uma lista de arquivos com nomes semelhantes no diretório indicado e uma lista de dataframes para receber os dados:\n\nfileNames = glob.glob(dir+\"relatorio_dados_enviados_coleta_20??.xlsx\")\ndfs = []\n\nAgora podemos ler cada um destes arquivos, filtrar linhas e colunas e anexar o dataframe filtrado à lista de dataframes:\n\nfor file in fileNames:\n    df = preprocessaProducoes(file)\n    dfs.append(df)\n\nEm uma linha concatenaremos todos os dataframes da produção intelectual do conjunto de planilhas:\n\ndfconcatenado = pd.concat(dfs, ignore_index=True)    \n\nDevemos manter somente as produções que não foram glosadas:\n\n#dfconcatenado = dfconcatenado[dfconcatenado['Produção Glosada?'] == 'Não']\n#dfconcatenado.drop(columns=['Produção Glosada?'], inplace=True)\n\nAgora temos todas as produções intelectuais de todos os anos que foram coletados na Plataforma Sucupira sobre nosso programa de pós-graduação. Mas estes dados ainda não estão prontos para a análise que queremos fazer: cada registro no dataframe contém informação sobre uma produção e um autor, portanto uma produção com quatro autores está representada em quatro registros.\nPodemos entender melhor este dataframe temporário criando um subconjunto dele contendo somente registros do artigo “A PLATFORM FOR LAND USE AND LAND COVER DATA INTEGRATION AND TRAJECTORY ANALYSIS”. Para visualizar melhor este subconjunto visualizando-o como uma tabela (eliminando antes alguns campos redundantes para facilitar a visualização):",
    "crumbs": [
      "Dados Abertos",
      "Coautorias"
    ]
  },
  {
    "objectID": "dadosabertos-baixando.html",
    "href": "dadosabertos-baixando.html",
    "title": "Baixando Dados Abertos da CAPES",
    "section": "",
    "text": "Atenção!\n\n\n\nOs dados usados nesta seção podem ser baixados por qualquer usuário a partir do portal de dados abertos da CAPES.",
    "crumbs": [
      "Dados Abertos",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "dadosabertos-baixando.html#sec-dados-abertos-obter",
    "href": "dadosabertos-baixando.html#sec-dados-abertos-obter",
    "title": "Baixando Dados Abertos da CAPES",
    "section": "Como obter os dados",
    "text": "Como obter os dados\nA CAPES (Coordenação de Aperfeiçoamento de Pessoal de Nível Superior) mantém várias coleções temáticas de dados abertos que podem ser usados para pesquisa. Alguns destes dados são alimentados pela Plataforma Sucupira e contém informações sobre todos os programas de pós-graduação stricto sensu do Brasil.\nPor usar como fonte a Plataforma Sucupira os conjuntos de dados nas coleções cobrem até a última avaliação anual: em Maio de 2024, somente os dados até 2022 estavam disponíveis.\nPara acessar as coleções vá ao portal Dados Abertos CAPES. No portal são listados vários temas, como mostrados na figura abaixo.\n\nPara as análises deste documento vamos usar o tema Avaliação da Pós-Graduação Stricto Sensu:\n\nSelecionando esta opção aparecerá uma página onde podemos selecionar os conjuntos de dados por categoria ou filtrando por palavra-chave. Ao fazer uma busca ou seleção aparecerão descritores dos conjuntos, identificados por título e período de cobertura, como mostrado a seguir.\n\nAo clicar em um dos descritores veremos outra página com todos os arquivos daquela coleção, com links para baixar os arquivos.\nVejam que um conjunto de dados pode estar distribuído em várias páginas (por exemplo, dados de cursos estão nas páginas [2013 a 2016] Cursos da Pós-Graduação Stricto Sensu do Brasil, [2017 a 2020] Cursos da Pós-Graduação Stricto Sensu no Brasil e [2021 a 2024] Cursos da Pós-Graduação Stricto Sensu no Brasil, dados da Produção Intelectual estão distribuídos em nove páginas). Como os arquivos variam de acordo com a coleção veremos quais baixar nos exemplos específicos a seguir.",
    "crumbs": [
      "Dados Abertos",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "dadosabertos-baixando.html#sec-dados-abertos-cursos",
    "href": "dadosabertos-baixando.html#sec-dados-abertos-cursos",
    "title": "Baixando Dados Abertos da CAPES",
    "section": "Dados sobre Cursos da Pós-Graduação Stricto Sensu no Brasil",
    "text": "Dados sobre Cursos da Pós-Graduação Stricto Sensu no Brasil\nVamos começar baixando as planilhas com os dados dos cursos de pós-graduação. Elas estão distribuídas em três páginas no Portal de Dados Abertos: [2013 a 2016] Cursos da Pós-Graduação Stricto Sensu do Brasil, [2017 a 2020] Cursos da Pós-Graduação Stricto Sensu no Brasil e [2021 a 2024] Cursos da Pós-Graduação Stricto Sensu no Brasil. Cada página contém links para baixar as planilhas nos formatos .csv e .xlsx, para cada um dos anos da coleção, além de arquivos com metadados. A figura abaixo mostra os links para acesso às planilhas com dados entre 2013 e 2016.\n\nPara as nossas análises vamos usar os arquivos .xlsx, que podem ser baixados clicando nos ícones verdes com uma seta para baixo e aguardar o início do download. Os arquivos baixados são mostrados a seguir:\n\n\n\nTabela 1: Arquivos com dados sobre cursos\n\n\n\n\n\n\n\n\n\n\n\nNome do arquivo\nTamanho\nColunas\nLinhas\n\n\n\n\nbr-capes-colsucup-curso-2013a2016-2020-06-12_2013.xlsx\n792012\n28\n5646\n\n\nbr-capes-colsucup-curso-2013a2016-2020-06-12_2014.xlsx\n821140\n28\n5854\n\n\nbr-capes-colsucup-curso-2013a2016-2020-06-12_2015.xlsx\n854794\n28\n6060\n\n\nbr-capes-colsucup-curso-2013a2016-2020-06-12_2016.xlsx\n890656\n28\n6313\n\n\nbr-capes-colsucup-curso-2017-2021-11-10.xlsx\n923526\n28\n6494\n\n\nbr-capes-colsucup-curso-2018-2021-11-10.xlsx\n950909\n28\n6695\n\n\nbr-capes-colsucup-curso-2019-2021-11-10.xlsx\n991420\n28\n6950\n\n\nbr-capes-colsucup-curso-2020-2021-11-10.xlsx\n995363\n28\n7000\n\n\nbr-capes-colsucup-curso-2021-2023-11-30.xlsx\n1021464\n28\n7163\n\n\nbr-capes-colsucup-curso-2022-2023-11-30.xlsx\n1001124\n28\n7027",
    "crumbs": [
      "Dados Abertos",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "dadosabertos-baixando.html#sec-dados-abertos-docentes",
    "href": "dadosabertos-baixando.html#sec-dados-abertos-docentes",
    "title": "Baixando Dados Abertos da CAPES",
    "section": "Dados sobre Docentes da Pós-Graduação Stricto Sensu no Brasil",
    "text": "Dados sobre Docentes da Pós-Graduação Stricto Sensu no Brasil\nVamos também baixar as planilhas com os dados dos docentes de pós-graduação. Elas estão distribuídas em quatro páginas no Portal de Dados Abertos: [2004 a 2012] Docentes dos Programas de Pós-Graduação stricto sensu no Brasil, [2013 a 2016] Docentes da Pós-Graduação Stricto Sensu no Brasil, [2017 a 2020] Docentes da Pós-Graduação Stricto Sensu no Brasil e [2021 a 2024] Docentes da Pós-Graduação Stricto Sensu no Brasil. Cada página contém links para baixar as planilhas nos formatos .csv e .xlsx, para cada um dos anos da coleção, além de arquivos com metadados. A figura abaixo mostra os links para acesso às planilhas com dados entre 2004 e 2012.\n\nOs arquivos baixados, seus tamanhos em bytes, e suas quantidades de colunas e linhas (sem cabeçalho) são mostrados na tabela a seguir.\n\n\n\nTabela 2: Arquivos com dados sobre docentes\n\n\n\n\n\n\n\n\n\n\n\nNome do arquivo\nTamanho\nColunas\nLinhas\n\n\n\n\nbr-capes-colsucup-docente-2004a2012-2021-03-01.xlsx\n65227884\n33\n491773\n\n\nbr-capes-colsucup-docente-2013-2023-08-01.xlsx\n13784386\n42\n79622\n\n\nbr-capes-colsucup-docente-2014-2023-08-01.xlsx\n14842064\n42\n85650\n\n\nbr-capes-colsucup-docente-2015-2023-08-01.xlsx\n15626101\n42\n90307\n\n\nbr-capes-colsucup-docente-2016-2023-08-01.xlsx\n16477872\n42\n95246\n\n\nbr-capes-colsucup-docente-2017-2021-11-10.xlsx\n19000457\n41\n102279\n\n\nbr-capes-colsucup-docente-2018-2021-11-10.xlsx\n19435907\n41\n104531\n\n\nbr-capes-colsucup-docente-2019-2021-11-10.xlsx\n20148746\n41\n108346\n\n\nbr-capes-colsucup-docente-2020-2021-11-10.xlsx\n19782331\n41\n105575\n\n\nbr-capes-colsucup-docente-2021-2023-11-30.xlsx\n20025270\n41\n110059\n\n\nbr-capes-colsucup-docente-2022-2023-11-30.xlsx\n20267644\n41\n109548",
    "crumbs": [
      "Dados Abertos",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "dadosabertos-baixando.html#sec-dados-abertos-discentes",
    "href": "dadosabertos-baixando.html#sec-dados-abertos-discentes",
    "title": "Baixando Dados Abertos da CAPES",
    "section": "Dados sobre Discentes da Pós-Graduação Stricto Sensu no Brasil",
    "text": "Dados sobre Discentes da Pós-Graduação Stricto Sensu no Brasil\nO Portal de Dados Abertos também contém informações detalhadas sobre todos os discentes dos programas de pós-graduação stricto sensu do Brasil, organizados em planilhas, uma por ano, e separadas em vários grupos, cada um com sua página de acesso, em um total de quatro páginas. A figura abaixo mostra os links para acesso às planilhas com dados entre 2021 e 2024.\n\nVejam que apesar do conjunto de dados fazer referência aos anos 2021 a 2024, somente estão presentes links para 2021 e 2022, por causa dos prazos da coleta na Plataforma Sucupira (leiam sempre a descrição sobre o conjunto no portal!)\nDependendo da análise basta baixar os arquivos correspondentes aos anos de interesse, mas para completude e para ilustrar casos difíceis no preprocessamento vamos baixar todas as planilhas disponíveis. Para isto será necessário acessar também os conjuntos de dados [2004 a 2012] Discentes dos Programas de Pós-Graduação stricto sensu no Brasil, [2013 a 2016] Discentes da Pós-Graduação Stricto Sensu do Brasil e [2017 a 2020] Discentes da Pós-Graduação stricto sensu do Brasil.\nOs arquivos baixados, seus tamanhos em bytes, e suas quantidades de colunas e linhas (sem cabeçalho) são mostrados na tabela a seguir.\n\n\n\nTabela 3: Arquivos com dados sobre discentes\n\n\n\n\n\n\n\n\n\n\n\nNome do arquivo\nTamanho\nColunas\nLinhas\n\n\n\n\nbr-capes-colsucup-discentes-2004-2021-03-01.xlsx\n26195517\nAE (31)\n190038\n\n\nbr-capes-colsucup-discentes-2005-2021-03-01.xlsx\n29273270\nAE (31)\n212073\n\n\nbr-capes-colsucup-discentes-2006-2021-03-01.xlsx\n31559779\nAE (31)\n229290\n\n\nbr-capes-colsucup-discentes-2007-2021-03-01.xlsx\n34804116\nAE (31)\n252102\n\n\nbr-capes-colsucup-discentes-2008-2021-03-01.xlsx\n37449507\nAE (31)\n270170\n\n\nbr-capes-colsucup-discentes-2009-2021-03-01.xlsx\n42033259\nAE (31)\n290592\n\n\nbr-capes-colsucup-discentes-2010-2021-03-01.xlsx\n45629174\nAE (31)\n316398\n\n\nbr-capes-colsucup-discentes-2011-2021-03-01.xlsx\n49755534\nAE (31)\n345048\n\n\nbr-capes-colsucup-discentes-2012-2021-03-01.xlsx\n54409827\nAE (31)\n375260\n\n\nbr-capes-colsucup-discentes-2013-2021-03-01.xlsx\n52967544\nAK (37)\n300210\n\n\nbr-capes-colsucup-discentes-2014-2021-03-01.xlsx\n56048168\nAK (37)\n317846\n\n\nbr-capes-colsucup-discentes-2015-2021-03-01.xlsx\n59802222\nAK (37)\n338035\n\n\nbr-capes-colsucup-discentes-2016-2021-03-01.xlsx\n63325526\nAK (37)\n357353\n\n\nbr-capes-colsucup-discentes-2017-2023-12-01.xlsx\n62190534\nAK (37)\n374429\n\n\nbr-capes-colsucup-discentes-2018-2023-12-01.xlsx\n64833813\nAK (37)\n390174\n\n\nbr-capes-colsucup-discentes-2019-2023-12-01.xlsx\n66848001\nAK (37)\n401311\n\n\nbr-capes-colsucup-discentes-2020-2023-12-01.xlsx\n65222388\nAK (37)\n395870\n\n\nbr-capes-colsucup-discentes-2021-2023-11-30.xlsx\n72086227\nAK (37)\n420350\n\n\nbr-capes-colsucup-discentes-2022-2023-11-30.xlsx\n73083882\nAK (37)\n424081",
    "crumbs": [
      "Dados Abertos",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "dadosabertos-baixando.html#sec-dados-abertos-producao",
    "href": "dadosabertos-baixando.html#sec-dados-abertos-producao",
    "title": "Baixando Dados Abertos da CAPES",
    "section": "Dados sobre Produção Intelectual de Programas de Pós-Graduação Stricto Sensu no Brasil",
    "text": "Dados sobre Produção Intelectual de Programas de Pós-Graduação Stricto Sensu no Brasil\nVamos também baixar alguns dos dados sobre produção intelectual. Esta é a coleção mais complexa e variada dos dados abertos da CAPES, estando representada em três grupos: Produção Intelectual dos Programas de Pós-Graduação Stricto Sensu no Brasil, Autor da Produção Intelectual de Programas de Pós-Graduação Stricto Sensu no Brasil e Detalhes da Produção Intelectual dos Programas da Pós-Graduação Strictu Sensu do Brasil.\nA figura abaixo mostra parte dos links para acesso às planilhas com dados da produção intelectual entre 2021 e 2024.\n\n\n\n\n\n\n\nAtenção!\n\n\n\nCada um dos conjuntos de dados sobre produção intelectual pode ter várias planilhas associadas, correspondentes aos subtipos das produção intelectual. Em alguns casos um tipo e subtipo pode ter duas planilhas associadas, para divisão dos dados, evitando arquivos muito grandes.\n\n\nPara os exemplos nas outras seções usaremos somente as produções do tipo técnica e Subtipo Cartas, Mapas ou Similares e do tipo Bibliográfica e Subtipo Artigo em Periódico.\nOs arquivos baixados para produções do tipo técnica e Subtipo Cartas, Mapas ou Similares, seus tamanhos em bytes, e suas quantidades de colunas e linhas (sem cabeçalho) são mostrados na tabela a seguir.\n\n\n\nTabela 4: Arquivos com dados sobre Cartas, Mapas ou Similares\n\n\n\n\n\n\n\n\n\n\n\nNome do arquivo\nTamanho\nColunas\nLinhas\n\n\n\n\nbr-capes-col-prod-2004a2012-2018-08-01-tecnica-cartamap.xlsx\n349520\n31\n2251\n\n\nbr-capes-colsucup-producao-2013a2016-2017-11-01-tecnica-cartamap.xlsx\n224863\n25\n1756\n\n\nbr-capes-colsucup-producao-2017a2020-2022-06-22-tecnica-cartamap.xlsx\n391664\n25\n2914\n\n\nbr-capes-colsucup-producao-2021a2024-2023-10-31-tecnica-cartamap.xlsx\n157706\n29\n1036\n\n\n\n\n\n\nOs arquivos baixados para produções tipo Bibliográfica e Subtipo Artigo em Periódico, seus tamanhos em bytes, e suas quantidades de colunas e linhas (sem cabeçalho) são mostrados na tabela a seguir:\n\n\n\nTabela 5: Arquivos com dados sobre Artigos em Periódicos\n\n\n\n\n\n\n\n\n\n\n\nNome do arquivo\nTamanho\nColunas\nLinhas\n\n\n\n\nbr-capes-col-prod-2004a2012-2018-08-01-bibliografica-artpe.xlsx\n185157864\n31\n1039024\n\n\nbr-capes-colsucup-producao-2013a2016-2020-06-30-bibliografica-artpe.xlsx\n147873130\n29\n849903\n\n\nbr-capes-colsucup-producao-2017a2020-2023-11-30-bibliografica-artpe_parte1.xlsx\n81090821\n29\n581162\n\n\nbr-capes-colsucup-producao-2017a2020-2023-11-30-bibliografica-artpe_parte2.xlsx\n81386085\n29\n581162\n\n\nbr-capes-colsucup-producao-2021a2024-2023-10-31-bibliografica-artpe.xlsx\n92968228\n31\n642735",
    "crumbs": [
      "Dados Abertos",
      "Obtendo os dados"
    ]
  },
  {
    "objectID": "sucupira.html",
    "href": "sucupira.html",
    "title": "Sucupira",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  }
]
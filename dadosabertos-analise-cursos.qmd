---
title: "Análises e Gráficos sobre Cursos"
lightbox: true
lang: pt
---
## Sobre

Os dados sobre cursos foram [baixados](dadosabertos-baixando.qmd#sec-dados-abertos-cursos) do [Portal de Dados Abertos](https://dadosabertos.capes.gov.br/) e [preparados para análise](dadosabertos-preprocessamento-cursos.qmd). 

Neste documento veremos como criar alguns gráficos sobre os cursos e programas de pós-graduação usando estes dados.

## Análise Exploratória de Dados

Vamos iniciar com algumas perguntas básicas sobre os dados que podem ser respondidas em poucas linhas de código. Começamos importando as bibliotecas básicas:

```{python}
import pandas as pd
import plotly.express as px
from IPython.display import Markdown
from tabulate import tabulate
```
Vamos também ler a base de dados unificada.

```{python}
base = pd.read_csv("Resources/Data/DadosAbertos/Cursos.csv")
```

Para algumas análise vamos querer somente os cursos que estão em funcionamento em 2022 (ano mais recente com dados disponíveis na CAPES). Vamos criar uma versão filtrada da base:

```{python}
base2022 = base[(base['AN_BASE'] == 2022) & 
                (base['DS_SITUACAO_CURSO'] == "EM FUNCIONAMENTO")]
```

### Quantos programas de pós-graduação temos na base?

Para calcular quantos programas temos (lembrando que a base cobre vários anos e os programas podem aparecer mais de uma vez) contamos os valores únicos dos campos `CD_PROGRAMA_IES` e `CD_CURSO_PPG`:

```{python}
# Contamos os valores únicos para programas e cursos, para a base completa.
programas = base['CD_PROGRAMA_IES'].nunique()
cursos = base['CD_CURSO_PPG'].nunique()
# Mostramos o resultado:
print(f"Temos {programas} programas e {cursos} cursos na base completa.")
# Contamos os valores únicos para programas e cursos, para a base de programas em
# funcionamento em 2022.
programas = base2022['CD_PROGRAMA_IES'].nunique()
cursos = base2022['CD_CURSO_PPG'].nunique()
# Mostramos o resultado:
print(f"Temos {programas} programas e {cursos} cursos na base de programas\n"+
       "\tem funcionamento em 2022.")
```

#### Quantos por estado?

Para fazer a contagem de programas por estado primeiro agrupamos os valores por estado, selecionamos os programas e contamos quantos programas únicos temos. O resultado é ordenado pela contagem, do maior valor para o menor. Preservamos a região dos estados para uso posterior.

```{python}
porEstado = base2022.groupby(['SG_UF_PROGRAMA', 'NM_REGIAO'])\
                             ['CD_PROGRAMA_IES'].nunique().reset_index()
porEstado = porEstado.sort_values(by='CD_PROGRAMA_IES',ascending=False)
```

Mostramos o resultado como uma tabela:

```{python}
Markdown(tabulate(
  porEstado, 
  headers=["Estado","Região","Programas"],
  showindex=False,
))
```

#### Quantos por área de avaliação?

A CAPES considera 50 áreas de avaliação. Quantos programas temos em cada área?

```{python}
porÁrea = base2022.groupby('NM_AREA_AVALIACAO')['CD_PROGRAMA_IES'].nunique().reset_index()
porÁrea = porÁrea.sort_values(by='CD_PROGRAMA_IES',ascending=False)
```

Mostramos o resultado como uma tabela:

```{python}
Markdown(tabulate(
  porÁrea, 
  headers=["Área de Avaliação","Programas"],
  showindex=False,
))
```

::: {.callout-warning}
A base de dados usa dois campos para representar a área de avaliação: um com o código (`CD_AREA_AVALIACAO`) e um com o nome (`NM_AREA_AVALIACAO`). É importante observar que o mesmo código pode ser representado por dois nomes diferentes, como é o caso da área código 29, que é associada aos nomes das áreas `ARQUITETURA, URBANISMO E DESIGN` e `ARQUITETURA E URBANISMO`.
:::

#### Quantos programas Interdisciplinares por estado?

Vamos filtrar somente os com código da área de avaliação igual a 45, e agrupar por estado:

```{python}
base45 = base2022[(base2022['CD_AREA_AVALIACAO'] == 45)] 
porEstado45 = base45.groupby(['SG_UF_PROGRAMA', 'NM_REGIAO'])\
                             ['CD_PROGRAMA_IES'].nunique().reset_index()
porEstado45 = porEstado45.sort_values(by='CD_PROGRAMA_IES',ascending=False)
```

Mostramos o resultado como uma tabela:

```{python}
Markdown(tabulate(
  porEstado45, 
  headers=["Estado","Região","Programas"],
  showindex=False,
))
```

#### Quantos por Natureza Jurídica?

Vamos ver quantos programas temos para cada uma das naturezas jurídicas reconhecidas pela CAPES:

```{python}
porNatJur = base2022.groupby('CS_STATUS_JURIDICO')['CD_PROGRAMA_IES'].nunique().reset_index()
porNatJur = porNatJur.sort_values(by='CD_PROGRAMA_IES',ascending=False)
```

Mostramos o resultado como uma tabela:

```{python}
Markdown(tabulate(
  porNatJur, 
  headers=["Natureza Jurídica","Programas"],
  showindex=False,
))
```

### Mapas

```{python}
import json
```

```{python}
with open("Resources/Maps/brazil-states.geojson", 'r') as f:
    brazilGeojson = json.load(f)
```


## Alguns cruzamentos de dados com fontes externas

Vamos usar um _dataframe_ com indicadores sociais e econômicos por estado, [obtido do IBGE](dados-ibge.qmd) e já pré-processado, para visualizar relações entre PIB, percentual da população abaixo da linha de pobreza, número de escolas de ensino médio no estado, população e número de programas de pós-graduação.

::: {.callout-warning}
Outras variáveis socioeconômicas podem ser escolhidas, visite a seção [Dados do IBGE](dados-ibge.qmd) para ver como.
:::

Primeiro lemos as duas bases de dados complementares: 

```{python}
dadosSE = pd.read_csv("Resources/Data/OutrosDados/DadosIBGE.csv")
dadosPOP = pd.read_csv("Resources/Data/OutrosDados/IBGEPopulação.csv")
```

As bases devem ser unidas pela sigla do estado, que é um campo comum a todas elas mas representada por colunas diferentes (`SG_UF_PROGRAMA` no _dataframe_ com número de programas por estado e `Sigla` nos _dataframes_ com dados socioeconômicos e de população). 


```{python}
# Renomeamos a coluna que representa a sigla da UF nos dados por estado:
porEstado.rename(columns={'SG_UF_PROGRAMA': 'Sigla'}, inplace=True)
# Unimos com o dataframe de dados socioambientais:
união = pd.merge(porEstado, dadosSE, on='Sigla')
# Unimos com o dataframe de dados de população, usando um sufixo para marcar
# colunas que podem estar repetidas:
união = pd.merge(união, dadosPOP, on='Sigla',suffixes=('', '_POP'))
# Eliminamos as colunas que podem estar repetidas usando o sufixo:
união = união.drop(columns=[col for col in união.columns if col.endswith('_POP')])
``` 

Agora temos um _dataframe_ com a quantidade de programas de pós-graduação por estado, anotado com várias variáveis socioambientais sobre os estados, mais população estratificada e área. Podemos explorar alguns gráficos que mostram relações entre estas variáveis.

Um gráfico do tipo bolha pode mostrar as relações entre várias variáveis numéricas. Usaremos a biblioteca [Plotly](https://plotly.com/python/) para criar o gráfico, com bolhas representando os estados, tamanho das bolhas proporcionais ao número de programas e cores representando as regiões.

Vamos visualizar a área do estado e total da população com o número de programas de pós-graduação por estado:

```{python}
# Criamos o gráfico.
fig = px.scatter(união, 
                 x='Área', 
                 y='Total', 
                 size='CD_PROGRAMA_IES', 
                 color='NM_REGIAO',
                 hover_name='Sigla', 
                 size_max=100,
                 title='Área x Total População x Programas de Pós-Graduação',
                 labels={
                   'Total': 'População Total',
                 },
                 custom_data=['NM_REGIAO','Área', 'Total', 'CD_PROGRAMA_IES'])
# Modificamos o layout e customizamos a legenda flutuante.
fig.update_layout(showlegend=False)
fig.update_traces(
    hovertemplate='<b>Estado: %{hovertext}</b><br>' +
                  'Região: %{customdata[0]}<br>' +
                  'Área: %{customdata[1]} km&#178;<br>' +
                  'População: %{customdata[2]}<br>' +
                  'Número de Programas: %{customdata[3]}<br>' +
                  '<extra></extra>'
)
# Mostramos o gráfico:
fig.show()
```

Para ver uma relação diferente vamos calcular o PIB per capita e plotar contra o percentual da população abaixo da linha de pobreza, usando como marcadores e número de programas de pós-graduação por estado:

```{python}
# Criamos uma nova coluna para o eixo X.
união['PIB_per_Capita'] = união['PIB'] / união['Total']
# Criamos também uma versão formatada para uso no indicador flutuante.
união['fPIB_per_Capita'] = união['PIB_per_Capita'].apply(lambda x: f'{x:.2f}')
# Criamos o gráfico.
fig = px.scatter(união, 
                 x='PIB_per_Capita', 
                 y='PALB', 
                 size='CD_PROGRAMA_IES', 
                 color='NM_REGIAO',
                 hover_name='Sigla', 
                 size_max=100,
                 title='PIB per capita x PALB x Programas de Pós-Graduação',
                 labels={
                   'PIB_per_Capita': 'Produto Interno Bruto (PIB) per capita',
                   'PALB': 'População Abaixo da Linha de Pobreza (%)',
                 },
                 custom_data=['NM_REGIAO', 'fPIB_per_Capita', 'Total', 'PALB', 'CD_PROGRAMA_IES'])
# Modificamos o layout e customizamos a legenda flutuante.
fig.update_layout(showlegend=False)
fig.update_traces(
    hovertemplate='<b>Estado: %{hovertext}</b><br>' +
                  'Região: %{customdata[0]}<br>' +
                  'PIB per capita: %{customdata[1]}<br>' +
                  'População: %{customdata[2]}<br>' +
                  '% Abaixo da Linha de Pobreza: %{customdata[3]}<br>' +
                  'Número de Programas: %{customdata[4]}<br>' +
                  '<extra></extra>'
) 
# Mostramos o gráfico:
fig.show()
```



```{python}
```

```{python}
```

```{python}
```

